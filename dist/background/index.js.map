{"version":3,"file":"background/index.js","mappings":";;;;;;;;;;;;;;;;AAAA;;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;;;;;;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;;AAEA;AAEA;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA","sources":["webpack://longport-ai/./src/utils/error-handler.ts","webpack://longport-ai/webpack/bootstrap","webpack://longport-ai/webpack/runtime/define property getters","webpack://longport-ai/webpack/runtime/hasOwnProperty shorthand","webpack://longport-ai/webpack/runtime/make namespace object","webpack://longport-ai/./src/background/index.ts"],"sourcesContent":["/**\n * LongPort AI 助手 - 错误处理工具\n */\n\n// 错误类型枚举\nexport enum ErrorType {\n  API_NOT_CONFIGURED = 'API_NOT_CONFIGURED',\n  NETWORK_ERROR = 'NETWORK_ERROR',\n  API_ERROR = 'API_ERROR',\n  TIMEOUT_ERROR = 'TIMEOUT_ERROR',\n  PERMISSION_ERROR = 'PERMISSION_ERROR',\n  CONNECTION_ERROR = 'CONNECTION_ERROR',\n  SCRIPT_INJECTION_ERROR = 'SCRIPT_INJECTION_ERROR',\n  MESSAGE_ERROR = 'MESSAGE_ERROR',\n  RESPONSE_ERROR = 'RESPONSE_ERROR',\n  UNKNOWN_ERROR = 'UNKNOWN_ERROR'\n}\n\n// 错误信息接口\nexport interface ErrorInfo {\n  type: ErrorType;\n  message: string;\n  details?: string;\n  suggestion?: string;\n}\n\n// 错误处理类\nexport class ErrorHandler {\n  // 根据错误类型获取用户友好的错误信息\n  static getErrorInfo(error: any): ErrorInfo {\n    // API未配置\n    if (error === ErrorType.API_NOT_CONFIGURED || error === 'API_NOT_CONFIGURED') {\n      return {\n        type: ErrorType.API_NOT_CONFIGURED,\n        message: 'API 未配置',\n        details: '请先在设置页面配置 API 地址和密钥',\n        suggestion: '点击\"前往设置\"按钮进行配置'\n      };\n    }\n    \n    // 网络错误\n    if (error instanceof Error && (error.message.includes('network') || error.message.includes('fetch'))) {\n      return {\n        type: ErrorType.NETWORK_ERROR,\n        message: '网络连接错误',\n        details: '无法连接到 API 服务器，请检查网络连接',\n        suggestion: '请确保您的网络连接正常，然后重试'\n      };\n    }\n    \n    // API错误\n    if (typeof error === 'string' && error.startsWith('API错误:')) {\n      const statusCode = error.split(':')[1]?.trim();\n      return {\n        type: ErrorType.API_ERROR,\n        message: `API 服务器错误 (${statusCode})`,\n        details: '服务器返回了错误响应',\n        suggestion: '请稍后重试，或联系管理员检查 API 服务状态'\n      };\n    }\n    \n    // 超时错误\n    if (error instanceof Error && error.message.includes('timeout')) {\n      return {\n        type: ErrorType.TIMEOUT_ERROR,\n        message: '请求超时',\n        details: 'API 请求响应时间过长',\n        suggestion: '请稍后重试，或检查网络连接'\n      };\n    }\n    \n    // 权限错误\n    if (error instanceof Error && error.message.includes('permission')) {\n      return {\n        type: ErrorType.PERMISSION_ERROR,\n        message: '权限错误',\n        details: '扩展程序缺少必要的权限',\n        suggestion: '请在扩展管理页面检查权限设置'\n      };\n    }\n    \n    // 连接错误\n    if (error === ErrorType.CONNECTION_ERROR || \n        (typeof error === 'string' && (\n          error.includes('connection') || \n          error.includes('Could not establish connection') ||\n          error.includes('Receiving end does not exist')\n        ))) {\n      return {\n        type: ErrorType.CONNECTION_ERROR,\n        message: '通信连接错误',\n        details: '无法建立扩展内部组件之间的连接',\n        suggestion: '请刷新页面或重新加载扩展后重试'\n      };\n    }\n    \n    // 脚本注入错误\n    if (error === ErrorType.SCRIPT_INJECTION_ERROR || \n        (error instanceof Error && error.message.includes('script'))) {\n      return {\n        type: ErrorType.SCRIPT_INJECTION_ERROR,\n        message: '脚本注入错误',\n        details: '无法在当前页面注入内容脚本',\n        suggestion: '请检查当前页面是否允许扩展程序运行'\n      };\n    }\n    \n    // 消息错误\n    if (error === ErrorType.MESSAGE_ERROR || \n        (error instanceof Error && error.message.includes('message'))) {\n      return {\n        type: ErrorType.MESSAGE_ERROR,\n        message: '消息传递错误',\n        details: '扩展内部组件之间的消息传递失败',\n        suggestion: '请刷新页面或重新启动浏览器后重试'\n      };\n    }\n    \n    // 响应错误\n    if (error === ErrorType.RESPONSE_ERROR || \n        (error instanceof Error && error.message.includes('response'))) {\n      return {\n        type: ErrorType.RESPONSE_ERROR,\n        message: '响应处理错误',\n        details: '无法处理服务器响应',\n        suggestion: '请稍后重试，如果问题持续存在，请联系管理员'\n      };\n    }\n    \n    // 未知错误\n    return {\n      type: ErrorType.UNKNOWN_ERROR,\n      message: '发生未知错误',\n      details: error instanceof Error ? error.message : String(error),\n      suggestion: '请重试，如果问题持续存在，请联系管理员'\n    };\n  }\n  \n  // 记录错误日志\n  static logError(error: any): void {\n    const errorInfo = this.getErrorInfo(error);\n    // 使用JSON.stringify确保对象被正确序列化\n    console.error('[LongPort AI 助手] 错误:', JSON.stringify(errorInfo, null, 2));\n    \n    // 也输出原始错误对象，方便调试\n    if (error instanceof Error) {\n      console.error('[LongPort AI 助手] 原始错误:', error.message, error.stack);\n    } else if (typeof error === 'object') {\n      console.error('[LongPort AI 助手] 原始错误:', JSON.stringify(error, null, 2));\n    } else {\n      console.error('[LongPort AI 助手] 原始错误:', error);\n    }\n    \n    // 可以在这里添加更多错误处理逻辑，如错误上报等\n  }\n  \n  // 处理连接错误\n  static handleConnectionError(error: any, retryCallback?: () => void): ErrorInfo {\n    const errorInfo = this.getErrorInfo(error);\n    this.logError(error);\n    \n    // 如果是连接错误并且提供了重试回调，则尝试重试\n    if (errorInfo.type === ErrorType.CONNECTION_ERROR && retryCallback) {\n      console.log('[LongPort AI 助手] 尝试重新连接...');\n      setTimeout(retryCallback, 500); // 延迟500ms后重试\n    }\n    \n    return errorInfo;\n  }\n  \n  // 重试函数\n  static retry<T>(fn: () => Promise<T>, maxRetries: number = 3, delay: number = 500): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      const attempt = (attemptCount: number) => {\n        fn()\n          .then(resolve)\n          .catch((error) => {\n            if (attemptCount < maxRetries) {\n              console.log(`[LongPort AI 助手] 重试 ${attemptCount + 1}/${maxRetries}...`);\n              setTimeout(() => attempt(attemptCount + 1), delay * Math.pow(2, attemptCount)); // 指数退避\n            } else {\n              reject(error);\n            }\n          });\n      };\n      \n      attempt(0);\n    });\n  }\n}\n\n// 导出错误处理相关内容\nexport default ErrorHandler;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * LongPort AI 助手 - 后台服务\n */\n\nimport ErrorHandler, { ErrorType } from '../utils/error-handler';\n\n// 定义接口\ninterface OptimizeTextRequest {\n  type: 'OPTIMIZE_TEXT';\n  text: string;\n  isStrictMode?: boolean;\n}\n\ninterface OptimizeTextResponse {\n  success: boolean;\n  optimizedText?: string;\n  stats?: {\n    originalLength: number;\n    optimizedLength: number;\n    lengthDifference?: number;\n    percentageChange?: number;\n    originalChineseChars?: number;\n    optimizedChineseChars?: number;\n    originalEnglishWords?: number;\n    optimizedEnglishWords?: number;\n  };\n  error?: string;\n  details?: string; // 添加详细错误信息字段\n}\n\ninterface ApiSettings {\n  apiEndpoint: string;\n  apiKey: string;\n  strictMode: boolean;\n}\n\n// 创建右键菜单\nfunction createContextMenu() {\n  chrome.contextMenus.create({\n    id: 'optimizeText',\n    title: '润色一下',\n    contexts: ['selection']\n  });\n}\n\n// 监听扩展安装或更新事件\nchrome.runtime.onInstalled.addListener(details => {\n  if (details.reason === 'install') {\n    // 初始化扩展设置\n    chrome.storage.sync.set({\n      apiEndpoint: '',\n      apiKey: '',\n      strictMode: false\n    });\n    \n    // 安装后打开选项页\n    chrome.runtime.openOptionsPage();\n  }\n  \n  // 创建右键菜单\n  createContextMenu();\n});\n\n// 检查内容脚本是否已加载\nfunction checkContentScriptLoaded(tabId: number): Promise<boolean> {\n  return new Promise((resolve) => {\n    chrome.tabs.sendMessage(tabId, { type: 'PING' }, (response) => {\n      if (chrome.runtime.lastError || !response) {\n        resolve(false);\n      } else {\n        resolve(true);\n      }\n    });\n  });\n}\n\n// 注入内容脚本\nasync function injectContentScript(tabId: number): Promise<void> {\n  return new Promise((resolve, reject) => {\n    console.log(`开始向标签页 ${tabId} 注入内容脚本...`);\n    \n    // 先注入JS文件\n    chrome.scripting.executeScript({\n      target: { tabId },\n      files: ['content/index.js']\n    }, (results) => {\n      if (chrome.runtime.lastError) {\n        console.error('注入内容脚本错误:', chrome.runtime.lastError.message);\n        reject(new Error(chrome.runtime.lastError.message));\n        return;\n      }\n      \n      console.log('JS脚本注入成功，开始注入CSS...');\n      \n      // 再注入CSS文件\n      chrome.scripting.insertCSS({\n        target: { tabId },\n        files: ['content/content.css']\n      }, () => {\n        if (chrome.runtime.lastError) {\n          console.error('注入CSS错误:', chrome.runtime.lastError.message);\n          // 即使CSS注入失败，也继续执行，因为JS可能已经注入成功\n          console.warn('CSS注入失败，但继续执行');\n        } else {\n          console.log('CSS注入成功');\n        }\n        \n        // 给脚本更多的加载时间\n        const timeout = 1000; // 增加到1000ms\n        console.log(`等待内容脚本初始化 ${timeout}ms...`);\n        setTimeout(() => {\n          console.log('内容脚本注入完成');\n          resolve();\n        }, timeout);\n      });\n    });\n  });\n}\n\n// 处理文本优化的通用函数\nasync function handleOptimizeText(tabId: number, selectedText: string): Promise<void> {\n  if (!selectedText || selectedText.trim().length === 0) {\n    console.log('没有选中文本，无法执行润色操作');\n    return;\n  }\n  \n  try {\n    console.log('优化文本', selectedText.substring(0, 20) + '...');\n    \n    // 检查内容脚本是否已加载\n    let isLoaded = await checkContentScriptLoaded(tabId);\n    \n    // 如果未加载，则注入内容脚本\n    if (!isLoaded) {\n      console.log('内容脚本未加载，正在注入...');\n      try {\n        await injectContentScript(tabId);\n        \n        // 给脚本更多的初始化时间\n        console.log('注入后等待额外时间确保脚本初始化...');\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        \n        // 再次检查脚本是否已加载\n        isLoaded = await checkContentScriptLoaded(tabId);\n        \n        if (!isLoaded) {\n          console.warn('内容脚本可能未完全加载，但仍将尝试发送消息...');\n        } else {\n          console.log('内容脚本已成功加载');\n        }\n      } catch (injectionError) {\n        console.error('注入内容脚本失败:', injectionError);\n        // 即使注入失败，也尝试发送消息，因为脚本可能已经部分加载\n        console.warn('尽管注入失败，仍将尝试发送消息...');\n      }\n        } else {\n      console.log('内容脚本已加载，无需注入');\n    }\n    \n    // 使用Promise包装消息发送，以便更好地处理错误\n    const sendMessagePromise = new Promise<void>((resolve, reject) => {\n      chrome.tabs.sendMessage(tabId, {\n        type: 'CONTEXT_MENU_OPTIMIZE',\n        text: selectedText\n      }, (response) => {\n        if (chrome.runtime.lastError) {\n          console.error('发送消息失败:', chrome.runtime.lastError.message);\n          reject(new Error(chrome.runtime.lastError.message));\n        } else if (response && response.received) {\n          console.log('消息发送成功，内容脚本已接收');\n          resolve();\n        } else {\n          console.warn('消息已发送，但未收到确认响应');\n          resolve(); // 仍然视为成功，因为消息可能已经发送\n        }\n      });\n    });\n    \n    // 添加超时处理\n    const timeoutPromise = new Promise<void>((_, reject) => {\n      setTimeout(() => reject(new Error('发送消息超时')), 5000); // 增加超时时间到5秒\n    });\n    \n    // 使用Promise.race竞争处理超时\n    try {\n      await Promise.race([sendMessagePromise, timeoutPromise]);\n    } catch (sendError) {\n      console.error('发送消息出错:', sendError);\n      \n      // 如果是超时错误，尝试重新注入脚本并再次发送\n      if (sendError instanceof Error && sendError.message === '发送消息超时') {\n        console.log('尝试重新注入脚本并重发消息...');\n        try {\n          await injectContentScript(tabId);\n          \n          // 等待脚本初始化\n          console.log('等待重新注入的脚本初始化...');\n          await new Promise(resolve => setTimeout(resolve, 1500));\n          \n          // 再次发送消息，使用Promise包装以便更好地处理错误\n          const resendPromise = new Promise<void>((resendResolve, resendReject) => {\n            chrome.tabs.sendMessage(tabId, {\n              type: 'CONTEXT_MENU_OPTIMIZE',\n              text: selectedText\n            }, (response) => {\n              if (chrome.runtime.lastError) {\n                console.error('重发消息失败:', chrome.runtime.lastError.message);\n                resendReject(new Error(chrome.runtime.lastError.message));\n              } else {\n                console.log('消息重发成功');\n                resendResolve();\n              }\n            });\n          });\n          \n          // 设置重发超时\n          const resendTimeout = new Promise<void>((_, reject) => {\n            setTimeout(() => reject(new Error('重发消息超时')), 5000);\n          });\n            \n                      try {\n            await Promise.race([resendPromise, resendTimeout]);\n          } catch (resendError) {\n            console.error('重发消息最终失败:', resendError);\n            // 此时已经尽力尝试，不再继续重试\n          }\n        } catch (reinjectionError) {\n          console.error('重新注入脚本失败:', reinjectionError);\n        }\n      }\n    }\n  } catch (error) {\n    console.error('处理文本优化时出错:', error);\n  }\n}\n\n// 处理右键菜单点击事件\nchrome.contextMenus.onClicked.addListener(async (info, tab) => {\n  if (info.menuItemId === 'optimizeText' && info.selectionText && tab && tab.id) {\n    await handleOptimizeText(tab.id, info.selectionText.trim());\n  }\n});\n\n// 监听快捷键命令\nchrome.commands.onCommand.addListener(async (command, tab) => {\n  console.log('Command received:', command);\n  \n  if (command === 'optimize-text' && tab?.id) {\n    // 获取当前选中的文本\n    try {\n      const [result] = await chrome.scripting.executeScript({\n        target: { tabId: tab.id },\n        func: () => window.getSelection()?.toString() || ''\n      });\n      \n      const selectedText = result.result.trim();\n      if (selectedText.length > 0) {\n        await handleOptimizeText(tab.id, selectedText);\n      } else {\n        console.log('没有选中文本，无法执行润色操作');\n      }\n    } catch (error) {\n      console.error('获取选中文本失败:', error);\n    }\n  }\n});\n\n// 模拟API响应（用于开发和测试）\nasync function mockApiResponse(text: string): Promise<OptimizeTextResponse> {\n  // 模拟处理延迟\n  await new Promise(resolve => setTimeout(resolve, 1500));\n  \n  // 简单的文本优化逻辑\n  let optimizedText = text;\n  \n  // 替换一些常见的错误或改进表达\n  optimizedText = optimizedText\n    .replace(/[,.，。;；]([^\\s])/g, '$1 ') // 标点符号后添加空格\n    .replace(/\\s+/g, ' ')                 // 规范化空格\n    .replace(/([a-zA-Z])[,.，。;；]([a-zA-Z])/g, '$1, $2') // 修复英文标点\n    .replace(/很很/g, '非常')              // 修复重复词\n    .replace(/的的/g, '的')\n    .replace(/了了/g, '了')\n    .replace(/我认为/g, '我们认为')         // 更正式的表达\n    .replace(/我觉得/g, '我们认为')\n    .replace(/不太好/g, '有待改进')         // 更专业的表达\n    .trim();\n  \n  // 如果文本没有变化，添加一些小改动\n  if (optimizedText === text) {\n    optimizedText = text + '（已优化）';\n  }\n  \n  // 计算统计信息\n  const originalLength = text.length;\n  const optimizedLength = optimizedText.length;\n  const lengthDifference = optimizedLength - originalLength;\n  const percentageChange = originalLength > 0 \n    ? Math.round((lengthDifference / originalLength) * 100) \n    : 0;\n  \n  // 分析中文字符数量\n  const countChineseChars = (str: string) => {\n    return (str.match(/[\\u4e00-\\u9fa5]/g) || []).length;\n  };\n  \n  // 分析英文单词数量\n  const countEnglishWords = (str: string) => {\n    return str.split(/\\s+/).filter(word => /[a-zA-Z]/.test(word)).length;\n  };\n  \n  const originalChineseChars = countChineseChars(text);\n  const optimizedChineseChars = countChineseChars(optimizedText);\n  const originalEnglishWords = countEnglishWords(text);\n  const optimizedEnglishWords = countEnglishWords(optimizedText);\n  \n  return {\n    success: true,\n    optimizedText,\n    stats: {\n      originalLength,\n      optimizedLength,\n      lengthDifference,\n      percentageChange,\n      originalChineseChars,\n      optimizedChineseChars,\n      originalEnglishWords,\n      optimizedEnglishWords\n    }\n  };\n}\n\n// 调用API优化文本\nasync function optimizeTextWithApi(text: string, isStrictMode: boolean, apiSettings: ApiSettings): Promise<OptimizeTextResponse> {\n  try {\n    // 检查API配置\n    if (!apiSettings.apiEndpoint || !apiSettings.apiKey || apiSettings.apiEndpoint.trim() === '') {\n      console.log('API未配置，使用模拟响应');\n      // 使用模拟API响应\n      return mockApiResponse(text);\n    }\n    \n    // 准备OpenAI标准格式的请求数据\n    const baseUrl = apiSettings.apiEndpoint.endsWith('/') \n      ? apiSettings.apiEndpoint.slice(0, -1) \n      : apiSettings.apiEndpoint;\n    \n    // 使用OpenAI标准的chat/completions端点\n    const openaiEndpoint = `${baseUrl}/v1/chat/completions`;\n    console.log(`使用OpenAI标准端点: ${openaiEndpoint}`);\n    \n    // 构建系统提示词，包含基础文本优化机制的要求\n    const systemPrompt = isStrictMode \n      ? \"你是一个严格的文案优化助手。请严格按照以下要求优化文本：1. 语法校正：修正错误的语法结构 2. 标点规范：统一标点符号使用 3. 中英混排规则：优化中英文混合排版 4. 语言风格：采用专业、清晰、友好的表达方式 5. 语调控制：保持克制，避免过度营销和夸张表达。优化原则：保持与原文语义一致，字数相当（不大幅增减），提升表达清晰度和专业性。\"\n      : \"你是一个专业的文案优化助手。请按照以下要求优化文本：1. 语法校正：修正错误的语法结构 2. 标点规范：统一标点符号使用 3. 中英混排规则：优化中英文混合排版 4. 语言风格：采用专业、清晰、友好的表达方式 5. 语调控制：保持克制，避免过度营销和夸张表达。优化原则：保持与原文语义一致，字数相当（不大幅增减），提升表达清晰度和专业性。\";\n    \n    // 准备OpenAI标准的请求数据\n    const openaiRequest = {\n      model: \"gpt-4o\", // 默认使用GPT-4o模型，可根据需要调整\n      messages: [\n        {\n          role: \"system\",\n          content: systemPrompt\n        },\n        {\n          role: \"user\",\n          content: `请优化以下文本，只返回优化后的文本，不要包含任何解释或其他内容：\\n\\n${text}`\n        }\n      ],\n      max_tokens: 2000,\n      temperature: 0.7\n    };\n    \n    console.log(`发送OpenAI请求数据:`, { model: openaiRequest.model, messages: openaiRequest.messages });\n    \n    // 使用错误重试机制调用API\n    const makeApiCall = async (): Promise<Response> => {\n      // 创建AbortController用于超时控制\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 30000); // 30秒超时\n      \n      try {\n        const response = await fetch(openaiEndpoint, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${apiSettings.apiKey}`,\n            'Accept': 'application/json',\n            'User-Agent': 'LongPort-AI-Extension/1.0.0'\n          },\n          body: JSON.stringify(openaiRequest),\n          signal: controller.signal\n        });\n        \n        // 清除超时\n        clearTimeout(timeoutId);\n        return response;\n      } catch (error) {\n        // 清除超时\n        clearTimeout(timeoutId);\n        \n        // 检查是否是超时错误\n        if (error instanceof DOMException && error.name === 'AbortError') {\n          throw new Error('请求超时，请稍后重试');\n        }\n        \n        // 重新抛出其他错误\n        throw error;\n      }\n    };\n    \n    // 使用ErrorHandler的retry方法进行重试，最多3次，每次间隔500ms\n    const response = await ErrorHandler.retry(makeApiCall, 3, 500);\n    \n    // 检查响应状态\n    if (!response.ok) {\n      try {\n        // 尝试解析错误响应为JSON\n        const errorData = await response.json().catch(async () => {\n          // 如果不是JSON，尝试获取文本内容\n          const textContent = await response.text().catch(() => '');\n          return { \n            message: `API错误: ${response.status}`, \n            details: textContent.substring(0, 100) // 只取前100个字符避免过长\n          };\n        });\n        return {\n          success: false,\n          error: errorData.message || `API错误: ${response.status}`\n        };\n      } catch (parseError) {\n        // 解析错误响应时出错\n        return {\n          success: false,\n          error: `API错误: ${response.status}, 无法解析错误详情`\n        };\n      }\n    }\n    \n    // 先获取响应内容类型\n    const contentType = response.headers.get('content-type') || '';\n    \n    // 检查是否是JSON响应\n    if (!contentType.includes('application/json')) {\n      try {\n        // 尝试获取文本内容\n        const textContent = await response.text().catch(() => '');\n        \n        // 检查是否是常见的错误页面\n        if (textContent.includes('<!doctype html>') || textContent.includes('<html')) {\n          // 可能是404页面或其他HTML错误页面\n          console.log('API返回了HTML页面而非JSON数据，自动使用模拟API');\n          \n          // 直接使用模拟API响应，不返回错误\n          return mockApiResponse(text);\n        }\n        \n        // 如果是其他非JSON格式\n        console.log('API返回了非JSON格式数据，自动使用模拟API');\n        \n        // 直接使用模拟API响应，不返回错误\n        return mockApiResponse(text);\n      } catch (textError) {\n        console.error('读取API响应内容时出错:', textError);\n        \n        // 如果出错，使用模拟响应\n        console.log('处理API响应出错，自动使用模拟API');\n        return mockApiResponse(text);\n      }\n    }\n    \n    try {\n      // 解析响应数据\n      const data = await response.json();\n      \n      // 从OpenAI响应中提取优化后的文本\n      let optimizedText = '';\n      if (data && data.choices && data.choices.length > 0 && data.choices[0].message) {\n        optimizedText = data.choices[0].message.content.trim();\n      } else {\n        console.error('OpenAI响应格式不符合预期:', data);\n        return {\n          success: false,\n          error: 'API响应格式不符合预期',\n          details: JSON.stringify(data).substring(0, 100) // 只取前100个字符\n        };\n      }\n      \n      // 计算更详细的字数统计\n      const originalLength = text.length;\n      const optimizedLength = optimizedText.length;\n      const lengthDifference = optimizedLength - originalLength;\n      const percentageChange = originalLength > 0 \n        ? Math.round((lengthDifference / originalLength) * 100) \n        : 0;\n      \n      // 分析中文字符数量\n      const countChineseChars = (str: string) => {\n        return (str.match(/[\\u4e00-\\u9fa5]/g) || []).length;\n      };\n      \n      // 分析英文单词数量（简单估算）\n      const countEnglishWords = (str: string) => {\n        return str.split(/\\s+/).filter(word => /[a-zA-Z]/.test(word)).length;\n      };\n      \n      const originalChineseChars = countChineseChars(text);\n      const optimizedChineseChars = countChineseChars(optimizedText);\n      const originalEnglishWords = countEnglishWords(text);\n      const optimizedEnglishWords = countEnglishWords(optimizedText);\n      \n      return {\n        success: true,\n        optimizedText: optimizedText,\n        stats: {\n          originalLength,\n          optimizedLength,\n          lengthDifference,\n          percentageChange,\n          originalChineseChars,\n          optimizedChineseChars,\n          originalEnglishWords,\n          optimizedEnglishWords\n        }\n      };\n    } catch (jsonError) {\n      // JSON解析错误\n      ErrorHandler.logError(jsonError);\n      return {\n        success: false,\n        error: 'JSON解析错误',\n        details: jsonError instanceof Error ? jsonError.message : '未知错误'\n      };\n    }\n  } catch (error) {\n    ErrorHandler.logError(error);\n    const errorInfo = ErrorHandler.getErrorInfo(error);\n    return {\n      success: false,\n      error: errorInfo.message\n    };\n  }\n}\n\n// 监听来自内容脚本的消息\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  if (message.type === 'OPTIMIZE_TEXT') {\n    // 获取API设置\n    chrome.storage.sync.get(['apiEndpoint', 'apiKey', 'strictMode'], (items) => {\n      const settings = items as unknown as ApiSettings;\n      \n      // 使用Promise包装异步操作，并处理错误\n      const processOptimizeRequest = async () => {\n        try {\n          // 检查是否强制使用模拟API\n          if (message.useMockApi) {\n            console.log('强制使用模拟API');\n            return await mockApiResponse(message.text);\n          }\n          \n          // 检查API配置是否有效\n          if (!settings.apiEndpoint || !settings.apiKey || settings.apiEndpoint.trim() === '') {\n            console.log('API未配置，自动使用模拟API');\n            return await mockApiResponse(message.text);\n          }\n          \n          try {\n            // 调用API优化文本\n            const result = await optimizeTextWithApi(\n              message.text,\n              message.isStrictMode !== undefined ? message.isStrictMode : settings.strictMode,\n              settings\n            );\n            return result;\n          } catch (apiError) {\n            // API调用出错，使用模拟API作为备用方案\n            console.log('API调用失败，自动使用模拟API:', apiError);\n            return await mockApiResponse(message.text);\n          }\n        } catch (error) {\n          // 如果模拟API也失败，记录错误并返回错误响应\n          ErrorHandler.logError(error);\n          \n          try {\n            // 最后尝试使用模拟API\n            return await mockApiResponse(message.text);\n          } catch (mockError) {\n            // 如果模拟API也失败，返回错误\n            const errorInfo = ErrorHandler.getErrorInfo(error);\n            return {\n              success: false,\n              error: errorInfo.message\n            };\n          }\n        }\n      };\n      \n      // 执行请求处理并发送响应\n      processOptimizeRequest()\n        .then(result => {\n          try {\n            sendResponse(result);\n          } catch (err) {\n            console.error('发送响应时出错:', err);\n          }\n        })\n        .catch(err => {\n          console.error('处理优化请求时出错:', err);\n          try {\n            sendResponse({\n              success: false,\n              error: '处理请求时发生未知错误'\n            });\n          } catch (responseErr) {\n            console.error('发送错误响应时出错:', responseErr);\n          }\n        });\n    });\n    \n    // 返回 true 表示将异步发送响应\n    return true;\n  }\n});\n\n// 导出一个空对象，确保这是一个有效的模块\nexport {};\n"],"names":[],"sourceRoot":""}