{"version":3,"file":"test/index.js","mappings":";;;;;;;;;;;AAAA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;;AAEA;AAEA;AA6BA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAMA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA2BA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA","sources":["webpack://longport-ai/./src/test/test.css?5cf1","webpack://longport-ai/webpack/bootstrap","webpack://longport-ai/webpack/runtime/make namespace object","webpack://longport-ai/./src/options/test.ts"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * LongPort AI 助手 - 文案优化测试页面脚本\n */\n\nimport '../test/test.css';\n\n// 导入优化的API客户端\n// 注意: 这里直接在代码中实现API客户端类，避免路径问题\n\n// 定义接口\ninterface OptimizeTextResponse {\n  success: boolean;\n  optimizedText?: string;\n  stats?: {\n    originalLength: number;\n    optimizedLength: number;\n    lengthDifference?: number;\n    percentageChange?: number;\n    originalChineseChars?: number;\n    optimizedChineseChars?: number;\n    originalEnglishWords?: number;\n    optimizedEnglishWords?: number;\n  };\n  error?: string;\n  details?: string;\n}\n\ninterface ApiSettings {\n  apiEndpoint: string;\n  apiKey: string;\n  strictMode: boolean;\n}\n\n// 简化版的 LRU 缓存实现\nclass SimpleCache {\n  private cache: Map<string, any>;\n  private capacity: number;\n  \n  constructor(capacity: number = 50) {\n    this.cache = new Map();\n    this.capacity = capacity;\n  }\n  \n  get(key: string): any {\n    if (!this.cache.has(key)) return undefined;\n    \n    const value = this.cache.get(key);\n    \n    if (value !== undefined) {\n      // 刷新键的位置\n      this.cache.delete(key);\n      this.cache.set(key, value);\n    }\n    \n    return value;\n  }\n  \n  set(key: string, value: any): void {\n    // 如果键已存在，先删除\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n    // 如果缓存已满，删除最旧的项\n    else if (this.cache.size >= this.capacity) {\n      // 获取第一个键删除\n      const keys = this.keys();\n      if (keys.length > 0) {\n        this.cache.delete(keys[0]);\n      }\n      // 已在上面处理\n    }\n    \n    // 添加新项\n    this.cache.set(key, value);\n  }\n  \n  keys(): string[] {\n    return Array.from(this.cache.keys());\n  }\n  \n  clear(): void {\n    this.cache.clear();\n  }\n  \n  size(): number {\n    return this.cache.size;\n  }\n}\n\n// 简化版的性能监控器\nclass SimplePerformanceMonitor {\n  private metrics: any;\n  \n  constructor() {\n    this.resetMetrics();\n  }\n  \n  recordRequest(isCached: boolean = false): number {\n    const timestamp = Date.now();\n    this.metrics.totalRequests++;\n    if (isCached) {\n      this.metrics.cachedResponses++;\n    }\n    return timestamp;\n  }\n  \n  recordResponse(startTime: number, success: boolean, responseTime: number): void {\n    if (success) {\n      this.metrics.successfulRequests++;\n    } else {\n      this.metrics.failedRequests++;\n    }\n    \n    this.metrics.totalResponseTime += responseTime;\n    this.metrics.maxResponseTime = Math.max(this.metrics.maxResponseTime, responseTime);\n    this.metrics.minResponseTime = Math.min(this.metrics.minResponseTime, responseTime);\n    \n    if (this.metrics.successfulRequests + this.metrics.failedRequests > 0) {\n      this.metrics.averageResponseTime = this.metrics.totalResponseTime / \n        (this.metrics.successfulRequests + this.metrics.failedRequests);\n    }\n  }\n  \n  getMetrics(): any {\n    return {\n      ...this.metrics,\n      currentRequestRate: 0, // 添加默认值以避免 undefined 错误\n      successRate: this.metrics.totalRequests > 0 \n        ? (this.metrics.successfulRequests / this.metrics.totalRequests * 100).toFixed(2) + '%'\n        : '0%',\n      cacheHitRate: this.metrics.totalRequests > 0\n        ? (this.metrics.cachedResponses / this.metrics.totalRequests * 100).toFixed(2) + '%'\n        : '0%'\n    };\n  }\n  \n  resetMetrics(): void {\n    this.metrics = {\n      totalRequests: 0,\n      successfulRequests: 0,\n      failedRequests: 0,\n      cachedResponses: 0,\n      averageResponseTime: 0,\n      totalResponseTime: 0,\n      maxResponseTime: 0,\n      minResponseTime: Number.MAX_VALUE\n    };\n  }\n}\n\n// 简化版的 API 客户端\nclass OptimizedApiClient {\n  private cache: SimpleCache;\n  private performanceMonitor: SimplePerformanceMonitor;\n  private similarityThreshold: number;\n  \n  constructor(options: any = {}) {\n    this.cache = new SimpleCache(options.cacheSize || 50);\n    this.performanceMonitor = new SimplePerformanceMonitor();\n    this.similarityThreshold = options.similarityThreshold || 0.85;\n  }\n  \n  async optimizeText(\n    text: string, \n    isStrictMode: boolean, \n    apiSettings: ApiSettings\n  ): Promise<OptimizeTextResponse> {\n    // 初始化返回值\n    let result: OptimizeTextResponse = {\n      success: false,\n      error: \"未知错误\"\n    };\n    \n    // 记录请求开始\n    const requestStartTime = this.performanceMonitor.recordRequest();\n    \n    // 检查缓存\n    const cacheKey = this.generateCacheKey(text, isStrictMode);\n    const cachedResponse = this.cache.get(cacheKey);\n    \n    if (cachedResponse) {\n      console.log(`[测试页面] 使用缓存响应，缓存键: ${cacheKey}`);\n      \n      // 记录缓存命中\n      this.performanceMonitor.recordResponse(\n        requestStartTime,\n        true,\n        Date.now() - requestStartTime\n      );\n      \n      return cachedResponse;\n    }\n    \n    // 检查相似文本缓存\n    const similarKey = this.findSimilarTextCacheKey(text, isStrictMode);\n    if (similarKey) {\n      const similarResponse = this.cache.get(similarKey);\n      if (similarResponse) {\n        console.log(`[测试页面] 使用相似文本缓存响应，缓存键: ${similarKey}`);\n        \n        // 记录缓存命中\n        this.performanceMonitor.recordResponse(\n          requestStartTime,\n          true,\n          Date.now() - requestStartTime\n        );\n        \n        return similarResponse;\n      }\n    }\n    \n    try {\n      // 真实 API 调用\n      const startCallTime = Date.now();\n      \n      // 检查 API 配置\n      if (!apiSettings.apiEndpoint || !apiSettings.apiKey) {\n        throw new Error('API 未配置');\n      }\n      \n      console.log(`[测试页面] 发起API调用，端点: ${apiSettings.apiEndpoint}`);\n      \n      // 准备请求数据 - 使用OpenAI标准格式\n      const baseUrl = apiSettings.apiEndpoint.endsWith('/') \n        ? apiSettings.apiEndpoint.slice(0, -1) \n        : apiSettings.apiEndpoint;\n      \n      // 使用OpenAI标准的chat/completions端点\n      const openaiEndpoint = `${baseUrl}/v1/chat/completions`;\n      \n      console.log(`[测试页面] 使用OpenAI标准端点: ${openaiEndpoint}`);\n      \n      // 准备OpenAI标准的请求数据格式 - 按优先级排序\n      const openaiRequestFormats = [\n        // 格式1：GPT-4.1 (最高优先级) - 基础优化\n        {\n          model: \"gpt-4.1\",\n          messages: [\n            {\n              role: \"system\",\n              content: \"你是一个专业的文案优化助手。请优化用户输入的文本，提升其专业性、清晰度和表达效果。保持原文语义不变，字数相当。\"\n            },\n            {\n              role: \"user\",\n              content: `请优化以下文本：${text}`\n            }\n          ],\n          max_tokens: 1000,\n          temperature: 0.7\n        },\n        // 格式2：GPT-4o (第二优先级) - 严格模式\n        {\n          model: \"gpt-4o\",\n          messages: [\n            {\n              role: \"system\",\n              content: \"你是一个严格的文案优化助手。请严格按照以下要求优化文本：1. 语法校正 2. 标点规范 3. 中英混排规则 4. 语言风格优化 5. 语调控制。保持原文语义一致，字数相当。\"\n            },\n            {\n              role: \"user\",\n              content: `请严格优化以下文本：${text}`\n            }\n          ],\n          max_tokens: 1000,\n          temperature: 0.5\n        },\n        // 格式3：Claude-3.7-sonnet (第三优先级) - 基础优化\n        {\n          model: \"claude-3-7-sonnet-20250219\",\n          messages: [\n            {\n              role: \"system\",\n              content: \"你是一个专业的文案优化助手。请优化用户输入的文本，提升其专业性、清晰度和表达效果。保持原文语义不变，字数相当。\"\n            },\n            {\n              role: \"user\",\n              content: `请优化以下文本：${text}`\n            }\n          ],\n          max_tokens: 1000,\n          temperature: 0.7\n        },\n        // 格式4：GPT-4o-mini (第四优先级) - 简化格式\n        {\n          model: \"gpt-4o-mini\",\n          messages: [\n            {\n              role: \"user\",\n              content: `优化文本：${text}`\n            }\n          ]\n        },\n        // 格式5：GPT-5-mini (第五优先级) - 备用格式\n        {\n          model: \"gpt-5-mini\",\n          messages: [\n            {\n              role: \"system\",\n              content: \"你是一个专业的文案优化助手。请优化用户输入的文本，提升其专业性、清晰度和表达效果。保持原文语义不变，字数相当。\"\n            },\n            {\n              role: \"user\",\n              content: `请优化以下文本：${text}`\n            }\n          ],\n          max_tokens: 1000,\n          temperature: 0.7\n        }\n      ];\n      \n      // 记录请求数据\n      console.log(`[测试页面] 将尝试 ${openaiRequestFormats.length} 种OpenAI标准请求格式`);\n      \n      // 创建 AbortController 用于超时控制\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 30000); // 30秒超时\n      \n      try {\n        // 发送真实API请求\n        console.log(`[测试页面] 发送请求到: ${openaiEndpoint}`);\n        \n        // 准备OpenAI标准的请求头\n        const headers = new Headers();\n        headers.append('Content-Type', 'application/json');\n        \n        // 根据API密钥格式决定认证方式\n        if (apiSettings.apiKey.startsWith('Bearer ')) {\n          // 如果已经包含 Bearer 前缀，直接使用\n          headers.append('Authorization', apiSettings.apiKey);\n        } else {\n          // 否则添加 Bearer 前缀\n          headers.append('Authorization', `Bearer ${apiSettings.apiKey}`);\n        }\n        \n        // 添加请求ID和客户端版本\n        headers.append('X-Request-ID', `test-${Date.now()}`);\n        headers.append('X-Client-Version', '1.0.0');\n        headers.append('Accept', 'application/json');\n        headers.append('User-Agent', 'LongPort-AI-Extension/1.0.0');\n        \n        // 记录请求头\n        const headersObj: Record<string, string> = {};\n        headers.forEach((value, key) => {\n          headersObj[key] = value;\n        });\n        console.log(`[测试页面] 请求头:`, headersObj);\n        \n        // 尝试多种OpenAI标准请求格式\n        let data: any = null;\n        let successfulFormat = null;\n        \n        for (let i = 0; i < openaiRequestFormats.length; i++) {\n          const currentFormat = openaiRequestFormats[i];\n          console.log(`[测试页面] 尝试OpenAI格式 ${i + 1}:`, currentFormat);\n          \n          try {\n            const response = await fetch(openaiEndpoint, {\n              method: 'POST',\n              headers,\n              body: JSON.stringify(currentFormat),\n              signal: controller.signal,\n              mode: 'cors',\n              cache: 'no-cache'\n            });\n            \n            // 清除超时\n            clearTimeout(timeoutId);\n            \n            // 检查响应状态\n            if (!response.ok) {\n              console.warn(`[测试页面] 格式 ${i + 1} 返回错误状态: ${response.status}`);\n              continue; // 尝试下一个格式\n            }\n            \n            // 验证响应内容类型\n            const contentType = response.headers.get('content-type') || '';\n            console.log(`[测试页面] 格式 ${i + 1} 响应内容类型: ${contentType}`);\n            \n            // 解析响应数据\n            try {\n              const responseText = await response.text();\n              console.log(`[测试页面] 格式 ${i + 1} 响应原始内容:`, responseText.substring(0, 500) + (responseText.length > 500 ? '...' : ''));\n              \n              // 检查是否是HTML响应\n              if (responseText.trim().toLowerCase().startsWith('<!doctype') || \n                  responseText.trim().toLowerCase().startsWith('<html')) {\n                console.warn(`[测试页面] 格式 ${i + 1} 返回了HTML内容，跳过`);\n                continue; // 尝试下一个格式\n              }\n              \n              // 尝试将文本解析为JSON\n              try {\n                data = JSON.parse(responseText);\n                console.log(`[测试页面] 格式 ${i + 1} 解析成功:`, data);\n                \n                // 检查OpenAI标准响应格式\n                const hasValidOpenAIResponse = data && (\n                  data.choices && Array.isArray(data.choices) && data.choices.length > 0 ||\n                  data.usage ||\n                  data.model ||\n                  data.id ||\n                  data.object === 'chat.completion'\n                );\n                \n                if (hasValidOpenAIResponse) {\n                  successfulFormat = i + 1;\n                  console.log(`[测试页面] 格式 ${i + 1} 成功获取有效OpenAI响应，停止尝试`);\n                  break; // 找到有效格式，停止尝试\n                } else {\n                  console.warn(`[测试页面] 格式 ${i + 1} 响应不符合OpenAI标准格式`);\n                  continue; // 尝试下一个格式\n                }\n              } catch (jsonError) {\n                console.error(`[测试页面] 格式 ${i + 1} 解析JSON失败:`, jsonError);\n                continue; // 尝试下一个格式\n              }\n            } catch (parseError) {\n              console.error(`[测试页面] 格式 ${i + 1} 解析响应失败:`, parseError);\n              continue; // 尝试下一个格式\n            }\n          } catch (fetchError) {\n            console.error(`[测试页面] 格式 ${i + 1} 请求失败:`, fetchError);\n            continue; // 尝试下一个格式\n          }\n        }\n        \n        // 检查是否找到有效的响应格式\n        if (!data || !successfulFormat) {\n          throw new Error('所有OpenAI请求格式都失败了，请检查API配置和网络连接');\n        }\n        \n        console.log(`[测试页面] 使用OpenAI格式 ${successfulFormat} 成功调用API`);\n        \n        // 使用API返回的优化文本 - 从OpenAI响应中提取\n        const optimizedText = data.choices && data.choices[0] && data.choices[0].message \n          ? data.choices[0].message.content \n          : '无法获取优化文本';\n        \n        // 如果优化后的文本与原文相同，添加标记\n        if (text === optimizedText) {\n          console.warn('[测试页面] API返回的优化文本与原文相同');\n        }\n      \n      // 如果是严格模式，添加额外的优化\n      let finalText = optimizedText;\n      if (isStrictMode) {\n        finalText = finalText\n          .replace(/\\u53ef\\u80fd/g, '\\u6216\\u8bb8')\n          .replace(/\\u5927\\u6982/g, '\\u5927\\u7ea6')\n          .replace(/\\u5f88\\u591a/g, '\\u5927\\u91cf')\n          .replace(/\\u5f88\\u5927/g, '\\u663e\\u8457');\n        \n        // 添加严格模式标记\n        finalText = `${finalText} [严格模式优化]`;\n      }\n      \n      // 计算统计信息\n      const originalLength = text.length;\n      const optimizedLength = optimizedText.length;\n      const lengthDifference = optimizedLength - originalLength;\n      const percentageChange = originalLength > 0 \n        ? Math.round((lengthDifference / originalLength) * 100) \n        : 0;\n      \n      // 分析中文字符数量\n      const countChineseChars = (str: string) => {\n        return (str.match(/[\\u4e00-\\u9fa5]/g) || []).length;\n      };\n      \n      // 分析英文单词数量\n      const countEnglishWords = (str: string) => {\n        return str.split(/\\s+/).filter(word => /[a-zA-Z]/.test(word)).length;\n      };\n      \n      const originalChineseChars = countChineseChars(text);\n      const optimizedChineseChars = countChineseChars(optimizedText);\n      const originalEnglishWords = countEnglishWords(text);\n      const optimizedEnglishWords = countEnglishWords(optimizedText);\n      \n      // 创建响应对象\n      const apiResponse: OptimizeTextResponse = {\n        success: true,\n        optimizedText: finalText,\n        stats: {\n          originalLength,\n          optimizedLength,\n          lengthDifference,\n          percentageChange,\n          originalChineseChars,\n          optimizedChineseChars,\n          originalEnglishWords,\n          optimizedEnglishWords\n        }\n      };\n      \n      // 计算响应时间\n      const responseTime = Date.now() - startCallTime;\n      \n      // 缓存响应\n      this.cache.set(cacheKey, apiResponse);\n      \n      // 记录响应完成\n      this.performanceMonitor.recordResponse(\n        requestStartTime,\n        true,\n        Date.now() - startCallTime\n      );\n      \n      return apiResponse;\n            } catch (apiError) {\n        // 清除超时\n        clearTimeout(timeoutId);\n        \n        console.error('[测试页面] API调用出错:', apiError);\n        \n        // 如果是超时错误\n        if (apiError instanceof DOMException && apiError.name === 'AbortError') {\n          throw new Error('请求超时，请检查网络连接或API服务器状态');\n        }\n        \n        // 重新抛出错误，不使用备用方案\n        throw apiError;\n      }\n    } catch (error) {\n      // 记录错误响应\n      this.performanceMonitor.recordResponse(\n        requestStartTime,\n        false,\n        Date.now() - requestStartTime\n      );\n      \n      console.error('[测试页面] 处理请求失败:', error);\n      \n      // 返回错误，不使用备用方案\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : '未知错误'\n      };\n    }\n  }\n  \n  private generateCacheKey(text: string, isStrictMode: boolean): string {\n    return `${isStrictMode ? 'strict:' : 'basic:'}${text}`;\n  }\n  \n  private findSimilarTextCacheKey(text: string, isStrictMode: boolean): string | null {\n    const prefix = isStrictMode ? 'strict:' : 'basic:';\n    const keys = this.cache.keys();\n    \n    for (const key of keys) {\n      if (key.startsWith(prefix)) {\n        const cachedText = key.substring(prefix.length);\n        if (this.calculateSimilarity(text, cachedText) > this.similarityThreshold) {\n          return key;\n        }\n      }\n    }\n    \n    return null;\n  }\n  \n  private calculateSimilarity(text1: string, text2: string): number {\n    if (text1 === text2) return 1.0;\n    if (!text1 || !text2) return 0.0;\n    \n    // 简单的长度比例作为相似度估算\n    const maxLength = Math.max(text1.length, text2.length);\n    const minLength = Math.min(text1.length, text2.length);\n    \n    // 基础相似度\n    let similarity = minLength / maxLength;\n    \n    // 检查开头和结尾是否相似\n    const prefixLength = Math.min(30, Math.floor(minLength / 2));\n    if (text1.substring(0, prefixLength) === text2.substring(0, prefixLength)) {\n      similarity += 0.1; // 开头相似加分\n    }\n    \n    // 限制最大值为1.0\n    return Math.min(similarity, 1.0);\n  }\n  \n  /**\n   * 本地备用处理方案\n   * 当API调用失败时，使用本地文本优化逻辑\n   */\n  private handleFallbackProcessing(text: string, isStrictMode: boolean): OptimizeTextResponse {\n    console.log(`[测试页面] 使用本地备用处理方案`);\n    \n    // 根据产品文档中的基础文本优化实现机制进行优化\n    let optimizedText = text;\n    \n    // 1. 语法校正\n    optimizedText = optimizedText\n      .replace(/\\s{2,}/g, ' ')  // 删除多余空格\n      .replace(/[,.\\uff0c\\u3002;\\uff1b]([^\\s])/g, '$1 ')  // 标点符号后添加空格\n      .replace(/([a-zA-Z])[,.\\uff0c\\u3002;\\uff1b]([a-zA-Z])/g, '$1, $2');  // 修复英文标点\n    \n    // 2. 标点规范\n    optimizedText = optimizedText\n      .replace(/\\uff0c\\uff0c/g, ',')  // 删除重复逗号\n      .replace(/\\u3002\\u3002/g, '.')  // 删除重复句号\n      .replace(/\\uff1b\\uff1b/g, ';');  // 删除重复分号\n    \n    // 3. 中英混排规则\n    optimizedText = optimizedText\n      .replace(/([\\u4e00-\\u9fa5])([a-zA-Z])/g, '$1 $2')  // 中文后面的英文前添加空格\n      .replace(/([a-zA-Z])([\\u4e00-\\u9fa5])/g, '$1 $2');  // 英文后面的中文前添加空格\n    \n    // 4. 语言风格\n    optimizedText = optimizedText\n      .replace(/\\u6211\\u8ba4\\u4e3a/g, '\\u6211\\u4eec\\u8ba4\\u4e3a')  // 替换“我认为”为“我们认为”\n      .replace(/\\u6211\\u89c9\\u5f97/g, '\\u6211\\u4eec\\u8ba4\\u4e3a')  // 替换“我觉得”为“我们认为”\n      .replace(/\\u4e0d\\u592a\\u597d/g, '\\u6709\\u5f85\\u6539\\u8fdb')  // 替换“不太好”为“有待改\\u8fdb”\n      .replace(/\\u5f88\\u5f88/g, '\\u975e\\u5e38')  // 替换重复词\n      .replace(/\\u7684\\u7684/g, '\\u7684')\n      .replace(/\\u4e86\\u4e86/g, '\\u4e86');\n    \n    // 5. 语调控制\n    optimizedText = optimizedText\n      .replace(/\\uff01\\uff01+/g, '\\uff01')  // 删除多余的感叹号\n      .replace(/\\uff1f\\uff1f+/g, '\\uff1f');  // 删除多余的问号\n    \n    // 如果文本仍然没有变化，添加一些额外的优化\n    if (text === optimizedText) {\n      // 尝试更多的替换\n      optimizedText = optimizedText\n        .replace(/\\uff0c/g, ', ')  // 中文逗号改为英文逗号+空格\n        .replace(/\\u3002/g, '. ')  // 中文句号改为英文句号+空格\n        .replace(/\\uff1b/g, '; ');  // 中文分号改为英文分号+空格\n    }\n    \n    // 如果仍然没有变化，添加一个标记\n    if (text === optimizedText) {\n      optimizedText = text + \" (已使用本地优化)\";\n    }\n    \n    // 如果是严格模式，添加额外的优化\n    if (isStrictMode) {\n      optimizedText = optimizedText\n        .replace(/\\u53ef\\u80fd/g, '\\u6216\\u8bb8')\n        .replace(/\\u5927\\u6982/g, '\\u5927\\u7ea6')\n        .replace(/\\u5f88\\u591a/g, '\\u5927\\u91cf')\n        .replace(/\\u5f88\\u5927/g, '\\u663e\\u8457');\n      \n      optimizedText = `${optimizedText} [严格模式]`;\n    }\n    \n    // 计算统计信息\n    const originalLength = text.length;\n    const optimizedLength = optimizedText.length;\n    const lengthDifference = optimizedLength - originalLength;\n    const percentageChange = originalLength > 0 \n      ? Math.round((lengthDifference / originalLength) * 100) \n      : 0;\n    \n    // 分析中文字符数量\n    const countChineseChars = (str: string) => {\n      return (str.match(/[\\u4e00-\\u9fa5]/g) || []).length;\n    };\n    \n    // 分析英文单词数量\n    const countEnglishWords = (str: string) => {\n      return str.split(/\\s+/).filter(word => /[a-zA-Z]/.test(word)).length;\n    };\n    \n    const originalChineseChars = countChineseChars(text);\n    const optimizedChineseChars = countChineseChars(optimizedText);\n    const originalEnglishWords = countEnglishWords(text);\n    const optimizedEnglishWords = countEnglishWords(optimizedText);\n    \n    return {\n      success: true,\n      optimizedText,\n      stats: {\n        originalLength,\n        optimizedLength,\n        lengthDifference,\n        percentageChange,\n        originalChineseChars,\n        optimizedChineseChars,\n        originalEnglishWords,\n        optimizedEnglishWords\n      }\n    };\n  }\n  \n  getPerformanceMetrics(): any {\n    return this.performanceMonitor.getMetrics();\n  }\n  \n  getCacheStats(): any {\n    return {\n      size: this.cache.size(),\n      capacity: 50, // 默认容量\n      hitRate: this.performanceMonitor.getMetrics().cacheHitRate\n    };\n  }\n  \n  clearCache(): void {\n    this.cache.clear();\n    console.log('[测试页面] 缓存已清除');\n  }\n}\n\n// 定义设置接口\ninterface Settings {\n  apiEndpoint: string;\n  apiKey: string;\n  strictMode: boolean;\n}\n\n// 定义优化响应接口\ninterface OptimizeTextResponse {\n  success: boolean;\n  optimizedText?: string;\n  stats?: {\n    originalLength: number;\n    optimizedLength: number;\n    lengthDifference?: number;\n    percentageChange?: number;\n    originalChineseChars?: number;\n    optimizedChineseChars?: number;\n    originalEnglishWords?: number;\n    optimizedEnglishWords?: number;\n  };\n  error?: string;\n  details?: string;\n}\n\n// 创建API客户端实例\nlet apiClient: OptimizedApiClient | null = null;\n\n// 当前设置\nlet currentSettings: Settings | null = null;\n\n// 页面元素\nlet testTextArea: HTMLTextAreaElement;\nlet testModeSelect: HTMLSelectElement;\nlet useCacheModeCheckbox: HTMLInputElement;\nlet showPerformanceStatsCheckbox: HTMLInputElement;\nlet optimizeBtn: HTMLButtonElement;\nlet clearBtn: HTMLButtonElement;\nlet clearCacheBtn: HTMLButtonElement;\nlet loadingIndicator: HTMLElement;\nlet testResults: HTMLElement;\nlet originalTextElement: HTMLElement;\nlet optimizedTextElement: HTMLElement;\nlet processingTimeElement: HTMLElement;\nlet statsContainer: HTMLElement;\nlet copyResultBtn: HTMLButtonElement;\nlet performanceMetrics: HTMLElement;\nlet metricsContainer: HTMLElement;\nlet backBtn: HTMLButtonElement;\n\n// 初始化函数\nasync function initialize(): Promise<void> {\n  // 获取页面元素\n  testTextArea = document.getElementById('testText') as HTMLTextAreaElement;\n  testModeSelect = document.getElementById('testMode') as HTMLSelectElement;\n  useCacheModeCheckbox = document.getElementById('useCacheMode') as HTMLInputElement;\n  showPerformanceStatsCheckbox = document.getElementById('showPerformanceStats') as HTMLInputElement;\n  optimizeBtn = document.getElementById('optimizeBtn') as HTMLButtonElement;\n  clearBtn = document.getElementById('clearBtn') as HTMLButtonElement;\n  clearCacheBtn = document.getElementById('clearCacheBtn') as HTMLButtonElement;\n  loadingIndicator = document.getElementById('loadingIndicator') as HTMLElement;\n  testResults = document.getElementById('testResults') as HTMLElement;\n  originalTextElement = document.getElementById('originalText') as HTMLElement;\n  optimizedTextElement = document.getElementById('optimizedText') as HTMLElement;\n  processingTimeElement = document.getElementById('processingTime') as HTMLElement;\n  statsContainer = document.getElementById('statsContainer') as HTMLElement;\n  copyResultBtn = document.getElementById('copyResultBtn') as HTMLButtonElement;\n  performanceMetrics = document.getElementById('performanceMetrics') as HTMLElement;\n  metricsContainer = document.getElementById('metricsContainer') as HTMLElement;\n  backBtn = document.getElementById('backBtn') as HTMLButtonElement;\n  \n  // 加载设置\n  await loadSettings();\n  \n  // 初始化API客户端\n  initializeApiClient();\n  \n  // 添加事件监听器\n  setupEventListeners();\n  \n  // 填充示例文本\n  fillExampleText();\n  \n  // 更新性能指标\n  updatePerformanceMetrics();\n}\n\n// 加载设置\nasync function loadSettings(): Promise<void> {\n  return new Promise((resolve) => {\n    chrome.storage.sync.get(['apiEndpoint', 'apiKey', 'strictMode'], (items) => {\n      currentSettings = {\n        apiEndpoint: items.apiEndpoint || '',\n        apiKey: items.apiKey || '',\n        strictMode: items.strictMode || false\n      };\n      \n      // 设置严格模式选择\n      if (currentSettings.strictMode) {\n        testModeSelect.value = 'strict';\n      } else {\n        testModeSelect.value = 'basic';\n      }\n      \n      resolve();\n    });\n  });\n}\n\n// 初始化API客户端\nfunction initializeApiClient(): void {\n  apiClient = new OptimizedApiClient({\n    cacheSize: 50,\n    tokensPerSecond: 5,\n    maxTokens: 10,\n    similarityThreshold: 0.85\n  });\n  \n  console.log('API客户端已初始化');\n}\n\n// 设置事件监听器\nfunction setupEventListeners(): void {\n  // 执行优化按钮\n  optimizeBtn.addEventListener('click', optimizeText);\n  \n  // 清空内容按钮\n  clearBtn.addEventListener('click', clearContent);\n  \n  // 清除缓存按钮\n  clearCacheBtn.addEventListener('click', clearCache);\n  \n  // 复制结果按钮\n  copyResultBtn.addEventListener('click', copyResult);\n  \n  // 返回按钮\n  backBtn.addEventListener('click', () => {\n    window.location.href = 'options.html';\n  });\n  \n  // 显示性能指标切换\n  showPerformanceStatsCheckbox.addEventListener('change', () => {\n    if (showPerformanceStatsCheckbox.checked) {\n      performanceMetrics.classList.remove('hidden');\n      updatePerformanceMetrics();\n    } else {\n      performanceMetrics.classList.add('hidden');\n    }\n  });\n}\n\n// 填充示例文本\nfunction fillExampleText(): void {\n  if (!testTextArea.value) {\n    testTextArea.value = '这是一个文案优化测试示例。我认为这个功能很有用，但是还需要进行测试。通过这个测试，我们可以验证API的效果和性能，确保它能够正确的优化文案内容，提高文案的专业性和清晰度。';\n  }\n}\n\n// 执行文本优化\nasync function optimizeText(): Promise<void> {\n  if (!apiClient || !currentSettings) {\n    alert('API客户端未初始化或设置未加载');\n    return;\n  }\n  \n  const text = testTextArea.value.trim();\n  if (!text) {\n    alert('请输入需要优化的文本');\n    return;\n  }\n  \n  // 显示加载指示器\n  loadingIndicator.classList.add('active');\n  optimizeBtn.disabled = true;\n  \n  // 隐藏结果区域\n  testResults.classList.add('hidden');\n  \n  try {\n    // 记录开始时间\n    const startTime = performance.now();\n    \n    // 确定优化模式\n    const isStrictMode = testModeSelect.value === 'strict';\n    \n    // 禁用缓存（如果需要）\n    let textToOptimize = text;\n    if (!useCacheModeCheckbox.checked) {\n      // 生成随机字符串确保不命中缓存\n      const randomSuffix = Math.random().toString(36).substring(2, 15);\n      textToOptimize = text + ' ' + randomSuffix;\n    }\n    \n    // 调用API优化文本\n    const result = await apiClient.optimizeText(\n      textToOptimize,\n      isStrictMode,\n      {\n        apiEndpoint: currentSettings.apiEndpoint,\n        apiKey: currentSettings.apiKey,\n        strictMode: isStrictMode\n      }\n    );\n    \n    // 计算处理时间\n    const processingTime = Math.round(performance.now() - startTime);\n    \n    // 显示结果\n    displayResults(text, result, processingTime);\n    \n    // 更新性能指标\n    updatePerformanceMetrics();\n  } catch (error) {\n    console.error('优化文本时出错:', error);\n    alert(`优化失败: ${error instanceof Error ? error.message : '未知错误'}`);\n  } finally {\n    // 隐藏加载指示器\n    loadingIndicator.classList.remove('active');\n    optimizeBtn.disabled = false;\n  }\n}\n\n// 显示优化结果\nfunction displayResults(originalText: string, result: OptimizeTextResponse, processingTime: number): void {\n  // 设置处理时间\n  processingTimeElement.textContent = processingTime.toString();\n  \n  // 设置原始文本和优化文本\n  originalTextElement.textContent = originalText;\n  \n  if (result.success && result.optimizedText) {\n    optimizedTextElement.textContent = result.optimizedText;\n    \n    // 显示统计信息\n    displayStats(result.stats);\n  } else {\n    optimizedTextElement.textContent = `优化失败: ${result.error || '未知错误'}`;\n    statsContainer.innerHTML = '';\n  }\n  \n  // 显示结果区域\n  testResults.classList.remove('hidden');\n}\n\n// 显示统计信息\nfunction displayStats(stats?: OptimizeTextResponse['stats']): void {\n  if (!stats) {\n    statsContainer.innerHTML = '<div class=\"stat-item\">无统计数据</div>';\n    return;\n  }\n  \n  statsContainer.innerHTML = '';\n  \n  // 添加字数统计\n  addStatItem('原始长度', stats.originalLength);\n  addStatItem('优化长度', stats.optimizedLength);\n  \n  // 添加长度变化\n  if (stats.lengthDifference !== undefined) {\n    const changeClass = stats.lengthDifference > 0 ? 'positive' : (stats.lengthDifference < 0 ? 'negative' : '');\n    const changePrefix = stats.lengthDifference > 0 ? '+' : '';\n    addStatItem('长度变化', `${changePrefix}${stats.lengthDifference}`, changeClass);\n  }\n  \n  // 添加百分比变化\n  if (stats.percentageChange !== undefined) {\n    const changeClass = stats.percentageChange > 0 ? 'positive' : (stats.percentageChange < 0 ? 'negative' : '');\n    const changePrefix = stats.percentageChange > 0 ? '+' : '';\n    addStatItem('百分比变化', `${changePrefix}${stats.percentageChange}%`, changeClass);\n  }\n  \n  // 添加中文字符统计\n  if (stats.originalChineseChars !== undefined && stats.optimizedChineseChars !== undefined) {\n    addStatItem('原始中文字符', stats.originalChineseChars);\n    addStatItem('优化中文字符', stats.optimizedChineseChars);\n  }\n  \n  // 添加英文单词统计\n  if (stats.originalEnglishWords !== undefined && stats.optimizedEnglishWords !== undefined) {\n    addStatItem('原始英文单词', stats.originalEnglishWords);\n    addStatItem('优化英文单词', stats.optimizedEnglishWords);\n  }\n}\n\n// 添加统计项\nfunction addStatItem(label: string, value: string | number, valueClass: string = ''): void {\n  const statItem = document.createElement('div');\n  statItem.className = 'stat-item';\n  \n  const statLabel = document.createElement('span');\n  statLabel.className = 'stat-label';\n  statLabel.textContent = label + ': ';\n  \n  const statValue = document.createElement('span');\n  statValue.className = `stat-value ${valueClass}`;\n  statValue.textContent = value.toString();\n  \n  statItem.appendChild(statLabel);\n  statItem.appendChild(statValue);\n  statsContainer.appendChild(statItem);\n}\n\n// 清空内容\nfunction clearContent(): void {\n  testTextArea.value = '';\n  testResults.classList.add('hidden');\n}\n\n// 清除缓存\nfunction clearCache(): void {\n  if (apiClient) {\n    apiClient.clearCache();\n    alert('缓存已清除');\n    \n    // 更新性能指标\n    updatePerformanceMetrics();\n  }\n}\n\n// 复制结果\nfunction copyResult(): void {\n  if (optimizedTextElement.textContent) {\n    navigator.clipboard.writeText(optimizedTextElement.textContent)\n      .then(() => {\n        alert('已复制到剪贴板');\n      })\n      .catch(err => {\n        console.error('复制失败:', err);\n        alert('复制失败');\n      });\n  }\n}\n\n// 更新性能指标\nfunction updatePerformanceMetrics(): void {\n  if (!apiClient || !showPerformanceStatsCheckbox.checked) {\n    return;\n  }\n  \n  const metrics = apiClient.getPerformanceMetrics();\n  const cacheStats = apiClient.getCacheStats();\n  \n  metricsContainer.innerHTML = '';\n  \n  // 添加请求统计\n  addMetricItem('总请求数', metrics.totalRequests);\n  addMetricItem('成功请求', metrics.successfulRequests);\n  addMetricItem('失败请求', metrics.failedRequests);\n  addMetricItem('缓存命中', metrics.cachedResponses);\n  \n  // 添加响应时间统计\n  addMetricItem('平均响应时间', `${Math.round(metrics.averageResponseTime)}ms`);\n  addMetricItem('最长响应时间', `${metrics.maxResponseTime}ms`);\n  addMetricItem('最短响应时间', metrics.minResponseTime === Number.MAX_VALUE ? 'N/A' : `${metrics.minResponseTime}ms`);\n  \n  // 添加缓存统计\n  addMetricItem('缓存大小', `${cacheStats.size}/${cacheStats.capacity}`);\n  addMetricItem('缓存命中率', cacheStats.hitRate);\n  \n  // 添加其他指标\n  addMetricItem('当前请求速率', `${(metrics.currentRequestRate || 0).toFixed(2)}/秒`);\n  addMetricItem('成功率', metrics.successRate);\n  \n  // 显示性能指标区域\n  performanceMetrics.classList.remove('hidden');\n}\n\n// 添加指标项\nfunction addMetricItem(label: string, value: string | number): void {\n  const metricItem = document.createElement('div');\n  metricItem.className = 'stat-item';\n  \n  const metricLabel = document.createElement('span');\n  metricLabel.className = 'stat-label';\n  metricLabel.textContent = label + ': ';\n  \n  const metricValue = document.createElement('span');\n  metricValue.className = 'stat-value';\n  metricValue.textContent = value.toString();\n  \n  metricItem.appendChild(metricLabel);\n  metricItem.appendChild(metricValue);\n  metricsContainer.appendChild(metricItem);\n}\n\n// 页面加载完成后初始化\ndocument.addEventListener('DOMContentLoaded', initialize);\n\n// 导出一个空对象，确保这是一个有效的模块\nexport {};\n"],"names":[],"sourceRoot":""}