{"version":3,"file":"content/index.js","mappings":";;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;ACAA;;;;AAIA;AAWA;AACA;AAAA;AACA;AACA;AACA;AAuBA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAbA;AACA;AACA;AAWA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;;;;;;ACjYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;;;AAGA;AAEA;AACA;AAEA;AACA;AA4BA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAWA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA","sources":["webpack://longport-ai/./src/content/content.css?38a1","webpack://longport-ai/./src/utils/record-manager.ts","webpack://longport-ai/webpack/bootstrap","webpack://longport-ai/webpack/runtime/define property getters","webpack://longport-ai/webpack/runtime/hasOwnProperty shorthand","webpack://longport-ai/webpack/runtime/make namespace object","webpack://longport-ai/./src/content/index.ts"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","/**\n * LongPort AI 助手 - 优化记录管理器\n * \n * 用于管理文本优化历史记录，提供记录的保存、查询、删除等功能\n */\n\n// 优化统计信息接口\nexport interface OptimizationStats {\n  originalLength: number;\n  optimizedLength: number;\n  lengthDifference: number;\n  percentageChange: number;\n  processingTime?: number;\n}\n\n// 优化模式枚举\nexport enum OptimizationMode {\n  BASIC = 'basic',\n  STRICT = 'strict'\n}\n\n// 优化记录接口\nexport interface OptimizationRecord {\n  id: string;\n  timestamp: number;\n  sourceUrl: string;\n  sourceDomain: string;\n  originalText: string;\n  optimizedText: string;\n  mode: OptimizationMode;\n  stats: OptimizationStats;\n}\n\n// 记录过滤条件接口\nexport interface RecordFilter {\n  startDate?: number;\n  endDate?: number;\n  domain?: string;\n  searchText?: string;\n  mode?: OptimizationMode;\n}\n\n// 记录管理器类\nclass RecordManager {\n  private static instance: RecordManager;\n  private readonly STORAGE_KEY = 'optimizationRecords';\n  private readonly MAX_RECORDS = 100; // 最大记录数量\n  private readonly DEFAULT_RETENTION_DAYS = 30; // 默认保留天数\n\n  // 单例模式\n  public static getInstance(): RecordManager {\n    if (!RecordManager.instance) {\n      RecordManager.instance = new RecordManager();\n    }\n    return RecordManager.instance;\n  }\n\n  // 私有构造函数\n  private constructor() {}\n\n  /**\n   * 保存优化记录\n   * @param record 要保存的记录（不包含id和timestamp）\n   * @returns 保存后的完整记录\n   */\n  public async saveRecord(record: Omit<OptimizationRecord, 'id' | 'timestamp'>): Promise<OptimizationRecord> {\n    // 获取现有记录\n    const records = await this.getAllRecords();\n    \n    // 创建新记录\n    const newRecord: OptimizationRecord = {\n      ...record,\n      id: this.generateId(),\n      timestamp: Date.now()\n    };\n    \n    // 添加到记录列表\n    records.unshift(newRecord);\n    \n    // 如果记录数量超过最大值，删除最旧的记录\n    if (records.length > this.MAX_RECORDS) {\n      records.splice(this.MAX_RECORDS);\n    }\n    \n    // 保存记录\n    await this.saveAllRecords(records);\n    \n    return newRecord;\n  }\n\n  /**\n   * 获取所有优化记录\n   * @returns 优化记录数组\n   */\n  public async getAllRecords(): Promise<OptimizationRecord[]> {\n    return new Promise((resolve) => {\n      chrome.storage.local.get(this.STORAGE_KEY, (result) => {\n        const records = result[this.STORAGE_KEY] || [];\n        resolve(records);\n      });\n    });\n  }\n\n  /**\n   * 根据ID获取单条记录\n   * @param id 记录ID\n   * @returns 找到的记录，如果不存在则返回null\n   */\n  public async getRecordById(id: string): Promise<OptimizationRecord | null> {\n    const records = await this.getAllRecords();\n    return records.find(record => record.id === id) || null;\n  }\n\n  /**\n   * 根据条件筛选记录\n   * @param filter 筛选条件\n   * @returns 符合条件的记录数组\n   */\n  public async filterRecords(filter: RecordFilter): Promise<OptimizationRecord[]> {\n    const records = await this.getAllRecords();\n    \n    return records.filter(record => {\n      // 按日期范围筛选\n      if (filter.startDate && record.timestamp < filter.startDate) {\n        return false;\n      }\n      if (filter.endDate && record.timestamp > filter.endDate) {\n        return false;\n      }\n      \n      // 按域名筛选\n      if (filter.domain && record.sourceDomain !== filter.domain) {\n        return false;\n      }\n      \n      // 按优化模式筛选\n      if (filter.mode && record.mode !== filter.mode) {\n        return false;\n      }\n      \n      // 按文本内容搜索\n      if (filter.searchText) {\n        const searchLower = filter.searchText.toLowerCase();\n        const originalLower = record.originalText.toLowerCase();\n        const optimizedLower = record.optimizedText.toLowerCase();\n        \n        if (!originalLower.includes(searchLower) && !optimizedLower.includes(searchLower)) {\n          return false;\n        }\n      }\n      \n      return true;\n    });\n  }\n\n  /**\n   * 删除单条记录\n   * @param id 要删除的记录ID\n   * @returns 是否成功删除\n   */\n  public async deleteRecord(id: string): Promise<boolean> {\n    const records = await this.getAllRecords();\n    const initialLength = records.length;\n    \n    const filteredRecords = records.filter(record => record.id !== id);\n    \n    if (filteredRecords.length === initialLength) {\n      // 没有记录被删除\n      return false;\n    }\n    \n    await this.saveAllRecords(filteredRecords);\n    return true;\n  }\n\n  /**\n   * 清空所有记录\n   * @returns 是否成功清空\n   */\n  public async clearAllRecords(): Promise<boolean> {\n    return new Promise((resolve) => {\n      chrome.storage.local.remove(this.STORAGE_KEY, () => {\n        if (chrome.runtime.lastError) {\n          console.error('清空记录失败:', chrome.runtime.lastError);\n          resolve(false);\n        } else {\n          resolve(true);\n        }\n      });\n    });\n  }\n\n  /**\n   * 清理过期记录\n   * @param retentionDays 保留天数，默认为30天\n   * @returns 删除的记录数量\n   */\n  public async cleanupExpiredRecords(retentionDays: number = this.DEFAULT_RETENTION_DAYS): Promise<number> {\n    const records = await this.getAllRecords();\n    const initialLength = records.length;\n    \n    // 计算截止时间戳\n    const cutoffTimestamp = Date.now() - (retentionDays * 24 * 60 * 60 * 1000);\n    \n    // 过滤掉过期记录\n    const filteredRecords = records.filter(record => record.timestamp >= cutoffTimestamp);\n    \n    // 计算删除的记录数量\n    const deletedCount = initialLength - filteredRecords.length;\n    \n    if (deletedCount > 0) {\n      await this.saveAllRecords(filteredRecords);\n    }\n    \n    return deletedCount;\n  }\n\n  /**\n   * 导出记录为JSON字符串\n   * @returns JSON格式的记录数据\n   */\n  public async exportRecords(): Promise<string> {\n    const records = await this.getAllRecords();\n    return JSON.stringify(records, null, 2);\n  }\n\n  /**\n   * 导入记录\n   * @param jsonData JSON格式的记录数据\n   * @param replace 是否替换现有记录，默认为false（合并）\n   * @returns 导入的记录数量\n   */\n  public async importRecords(jsonData: string, replace: boolean = false): Promise<number> {\n    try {\n      const importedRecords = JSON.parse(jsonData) as OptimizationRecord[];\n      \n      if (!Array.isArray(importedRecords)) {\n        throw new Error('导入数据格式错误');\n      }\n      \n      // 验证记录格式\n      for (const record of importedRecords) {\n        if (!this.isValidRecord(record)) {\n          throw new Error('导入数据包含无效记录');\n        }\n      }\n      \n      if (replace) {\n        // 替换现有记录\n        await this.saveAllRecords(importedRecords);\n      } else {\n        // 合并记录\n        const existingRecords = await this.getAllRecords();\n        \n        // 使用Map去重，以ID为键\n        const recordMap = new Map<string, OptimizationRecord>();\n        \n        // 先添加现有记录\n        existingRecords.forEach(record => {\n          recordMap.set(record.id, record);\n        });\n        \n        // 再添加导入记录（如有重复ID则覆盖）\n        importedRecords.forEach(record => {\n          recordMap.set(record.id, record);\n        });\n        \n        // 转换回数组并按时间戳排序\n        const mergedRecords = Array.from(recordMap.values())\n          .sort((a, b) => b.timestamp - a.timestamp);\n        \n        // 如果超过最大记录数，截断\n        const finalRecords = mergedRecords.slice(0, this.MAX_RECORDS);\n        \n        await this.saveAllRecords(finalRecords);\n      }\n      \n      return importedRecords.length;\n    } catch (error) {\n      console.error('导入记录失败:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * 获取记录统计信息\n   * @returns 记录统计信息\n   */\n  public async getRecordStats(): Promise<{\n    totalCount: number;\n    oldestTimestamp: number | null;\n    newestTimestamp: number | null;\n    domainCounts: Record<string, number>;\n    modeCounts: Record<string, number>;\n  }> {\n    const records = await this.getAllRecords();\n    \n    if (records.length === 0) {\n      return {\n        totalCount: 0,\n        oldestTimestamp: null,\n        newestTimestamp: null,\n        domainCounts: {},\n        modeCounts: {}\n      };\n    }\n    \n    // 初始化统计\n    let oldestTimestamp = records[0].timestamp;\n    let newestTimestamp = records[0].timestamp;\n    const domainCounts: Record<string, number> = {};\n    const modeCounts: Record<string, number> = {};\n    \n    // 遍历记录进行统计\n    for (const record of records) {\n      // 更新时间戳\n      if (record.timestamp < oldestTimestamp) {\n        oldestTimestamp = record.timestamp;\n      }\n      if (record.timestamp > newestTimestamp) {\n        newestTimestamp = record.timestamp;\n      }\n      \n      // 统计域名\n      if (domainCounts[record.sourceDomain]) {\n        domainCounts[record.sourceDomain]++;\n      } else {\n        domainCounts[record.sourceDomain] = 1;\n      }\n      \n      // 统计模式\n      if (modeCounts[record.mode]) {\n        modeCounts[record.mode]++;\n      } else {\n        modeCounts[record.mode] = 1;\n      }\n    }\n    \n    return {\n      totalCount: records.length,\n      oldestTimestamp,\n      newestTimestamp,\n      domainCounts,\n      modeCounts\n    };\n  }\n\n  // 私有方法：保存所有记录\n  private async saveAllRecords(records: OptimizationRecord[]): Promise<void> {\n    return new Promise((resolve, reject) => {\n      chrome.storage.local.set({ [this.STORAGE_KEY]: records }, () => {\n        if (chrome.runtime.lastError) {\n          console.error('保存记录失败:', chrome.runtime.lastError);\n          reject(chrome.runtime.lastError);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  // 私有方法：生成唯一ID\n  private generateId(): string {\n    return Date.now().toString(36) + Math.random().toString(36).substring(2, 9);\n  }\n\n  // 私有方法：验证记录格式\n  private isValidRecord(record: any): boolean {\n    return (\n      typeof record === 'object' &&\n      typeof record.id === 'string' &&\n      typeof record.timestamp === 'number' &&\n      typeof record.sourceUrl === 'string' &&\n      typeof record.sourceDomain === 'string' &&\n      typeof record.originalText === 'string' &&\n      typeof record.optimizedText === 'string' &&\n      typeof record.mode === 'string' &&\n      typeof record.stats === 'object' &&\n      typeof record.stats.originalLength === 'number' &&\n      typeof record.stats.optimizedLength === 'number'\n    );\n  }\n}\n\n// 导出单例实例\nexport const recordManager = RecordManager.getInstance();\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * longPort AI - 内容脚本\n * 在网页中注入并执行\n */\n\nimport './content.css';\nimport { recordManager, OptimizationMode } from '../utils/record-manager';\n\n// 初始化日志\nconsole.log('longPort AI 内容脚本已加载', window.location.href);\n\n// 定义接口\ninterface OptimizeTextResponse {\n  success: boolean;\n  optimizedText?: string;\n  stats?: {\n    originalLength: number;\n    optimizedLength: number;\n    lengthDifference?: number;\n    percentageChange?: number;\n    originalChineseChars?: number;\n    optimizedChineseChars?: number;\n    originalEnglishWords?: number;\n    optimizedEnglishWords?: number;\n  };\n  error?: string;\n  details?: string;\n}\n\n// 声明全局变量\ndeclare global {\n  interface Window {\n    longPortAIReplaceText?: (text: string) => void;\n    tempRangeElement?: HTMLElement;\n  }\n}\n\n// 保存当前选中的文本和范围\nlet currentSelection: {\n  text: string;\n  range: Range | null;\n} | null = null;\n\n// 创建弹窗元素\nlet popupElement: HTMLDivElement | null = null;\nlet shadowRoot: ShadowRoot | null = null;\nlet shadowHost: HTMLDivElement | null = null;\n\n// 监听选中文本变化\ndocument.addEventListener('selectionchange', () => {\n  const selection = window.getSelection();\n  if (selection && selection.toString().trim().length > 0) {\n    currentSelection = {\n      text: selection.toString(),\n      range: selection.getRangeAt(0)\n    };\n  } else {\n    currentSelection = null;\n  }\n});\n\n// 保存快捷键配置\nlet optimizeShortcut = { altKey: true, ctrlKey: false, shiftKey: false, metaKey: false, key: 'o' };\nlet replaceShortcut = { altKey: false, ctrlKey: false, shiftKey: false, metaKey: false, key: ' ' };\n\n// 加载快捷键配置\nfunction loadShortcuts() {\n  chrome.storage.sync.get(['settings'], (result) => {\n    if (result.settings && result.settings.shortcuts) {\n      optimizeShortcut = result.settings.shortcuts.optimize;\n      replaceShortcut = result.settings.shortcuts.replace;\n      console.log('LongPort AI: 已加载快捷键配置', optimizeShortcut, replaceShortcut);\n    }\n  });\n}\n\n// 初始加载快捷键配置\nloadShortcuts();\n\n// 监听快捷键\ndocument.addEventListener('keydown', (event) => {\n  // 检查是否匹配优化快捷键\n  if (matchesShortcut(event, optimizeShortcut)) {\n    const selectedText = window.getSelection()?.toString();\n    if (selectedText && selectedText.trim().length > 0) {\n      optimizeText(selectedText);\n      event.preventDefault(); // 阻止默认行为\n    }\n  }\n  \n  // 检查是否匹配替换快捷键，且弹窗已显示\n  if (matchesShortcut(event, replaceShortcut) && popupElement) {\n    const replaceButton = popupElement.querySelector('.longport-ai-btn-primary');\n    if (replaceButton) {\n      (replaceButton as HTMLButtonElement).click();\n      event.preventDefault(); // 阻止默认行为\n    }\n  }\n});\n\n// 检查事件是否匹配快捷键配置\nfunction matchesShortcut(event: KeyboardEvent, shortcut: any): boolean {\n  return event.altKey === shortcut.altKey && \n         event.ctrlKey === shortcut.ctrlKey && \n         event.shiftKey === shortcut.shiftKey && \n         event.metaKey === shortcut.metaKey && \n         event.key.toLowerCase() === shortcut.key.toLowerCase();\n}\n\n// 监听设置变更\nchrome.storage.onChanged.addListener((changes, namespace) => {\n  if (namespace === 'sync' && changes.settings) {\n    const newSettings = changes.settings.newValue;\n    if (newSettings && newSettings.shortcuts) {\n      optimizeShortcut = newSettings.shortcuts.optimize;\n      replaceShortcut = newSettings.shortcuts.replace;\n      console.log('LongPort AI: 快捷键配置已更新', optimizeShortcut, replaceShortcut);\n    }\n  }\n});\n\n// 监听来自后台脚本的消息\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  console.log('longPort AI: 收到消息', message);\n  \n  try {\n    // 处理PING消息，用于检查内容脚本是否已加载\n    if (message.type === 'PING') {\n      console.log('longPort AI: 收到PING消息，回复PONG');\n      try {\n        sendResponse({ pong: true });\n        console.log('longPort AI: PONG响应已发送');\n      } catch (pingError) {\n        console.error('发送PING响应时出错:', pingError);\n      }\n      return true;\n    }\n    \n    // 处理替换文本命令\n    else if (message.type === 'REPLACE_TEXT') {\n      console.log('longPort AI: 收到替换文本命令');\n      \n      try {\n        // 立即回复，表示消息已收到\n        try {\n          sendResponse({ received: true });\n        } catch (responseError) {\n          console.error('发送接收确认响应时出错:', responseError);\n        }\n        \n        // 如果弹窗已显示，模拟点击替换按钮\n        if (popupElement) {\n          const replaceButton = popupElement.querySelector('.longport-ai-btn-primary');\n          if (replaceButton) {\n            console.log('执行替换操作');\n            (replaceButton as HTMLButtonElement).click();\n          } else {\n            console.warn('未找到替换按钮');\n          }\n        } else {\n          console.warn('弹窗未显示，无法执行替换操作');\n        }\n      } catch (error) {\n        console.error('处理替换文本命令时出错:', error);\n      }\n      return true;\n    }\n    \n    // 处理优化文本消息\n    else if (message.type === 'CONTEXT_MENU_OPTIMIZE' && message.text) {\n      console.log('longPort AI: 收到右键菜单优化文本消息', message.text.substring(0, 20) + '...');\n      \n      try {\n        // 立即回复，表示消息已收到\n        try {\n          sendResponse({ received: true });\n          console.log('已发送接收确认响应');\n        } catch (responseError) {\n          console.error('发送接收确认响应时出错:', responseError);\n        }\n        \n        // 保存选中文本和范围\n        // 直接使用传入的文本，不再尝试获取选中区域\n        // 这样可以避免在右键菜单点击后选中区域丢失的问题\n        currentSelection = {\n          text: message.text,\n          range: null // 稍后在优化文本函数中处理\n        };\n        console.log('已保存选中文本:', message.text.substring(0, 20) + '...');\n        \n        // 然后异步处理优化文本，避免阻塞消息响应\n        setTimeout(() => {\n          try {\n            console.log('开始异步处理优化文本...');\n            optimizeText(message.text);\n          } catch (error) {\n            console.error('处理优化文本时出错:', error);\n            showErrorPopup('处理文本时出错: ' + (error instanceof Error ? error.message : String(error)));\n          }\n        }, 100); // 增加延迟到100ms，给更多时间处理响应\n      } catch (processingError) {\n        console.error('处理优化文本消息时出错:', processingError);\n        try {\n          sendResponse({ error: String(processingError) });\n        } catch (responseError) {\n          console.error('发送错误响应时出错:', responseError);\n        }\n      }\n      \n      return true;\n    }\n    \n    // 对于未知消息类型，也返回响应\n    console.warn('收到未知类型的消息:', message.type);\n    try {\n      sendResponse({ received: true, unknown: true });\n    } catch (unknownResponseError) {\n      console.error('发送未知类型响应时出错:', unknownResponseError);\n    }\n    \n    // 返回 true 表示将异步发送响应\n    return true;\n  } catch (error) {\n    // 捕获所有异常，确保消息处理不会崩溃\n    console.error('处理消息时出错:', error);\n    try {\n      sendResponse({ error: String(error) });\n    } catch (responseError) {\n      console.error('发送错误响应时出错:', responseError);\n    }\n    return true;\n  }\n});\n\n// 文本优化函数\nfunction optimizeText(text: string): void {\n  console.log('开始优化文本:', text.substring(0, 20) + '...');\n  \n  // 如果currentSelection未设置或range为null，则尝试获取当前选中区域\n  if (!currentSelection || currentSelection.range === null) {\n    console.log('尝试获取选中区域或查找可编辑元素');\n    \n    // 尝试获取当前选中区域\n    const selection = window.getSelection();\n    if (selection && selection.rangeCount > 0 && selection.toString().trim().length > 0) {\n      console.log('检测到有效的选中区域');\n      if (!currentSelection) {\n        currentSelection = {\n          text,\n          range: selection.getRangeAt(0).cloneRange()\n        };\n      } else {\n        currentSelection.range = selection.getRangeAt(0).cloneRange();\n      }\n    } else {\n      // 尝试查找 Notion 特定的编辑器元素\n      console.log('尝试查找 Notion 特定的编辑器元素');\n      \n      // Notion 编辑器特定选择器\n      const notionSelectors = [\n        '.notion-page-content [contenteditable=\"true\"]',\n        '.notion-frame [contenteditable=\"true\"]',\n        '.notion-selectable [contenteditable=\"true\"]',\n        '.notranslate [contenteditable=\"true\"]'\n      ];\n      \n      let notionEditor = null;\n      \n      // 尝试每个 Notion 选择器\n      for (const selector of notionSelectors) {\n        const elements = document.querySelectorAll(selector);\n        if (elements.length > 0) {\n          notionEditor = elements[0];\n          console.log(`找到 Notion 编辑器元素: ${selector}`);\n          break;\n        }\n      }\n      \n      if (notionEditor) {\n        // 找到 Notion 编辑器元素\n        const range = document.createRange();\n        try {\n          range.selectNodeContents(notionEditor);\n          console.log('已选择 Notion 编辑器内容');\n          \n          if (!currentSelection) {\n            currentSelection = { text, range };\n          } else {\n            currentSelection.range = range;\n          }\n        } catch (e) {\n          console.warn('无法选择 Notion 编辑器内容，尝试其他方法', e);\n          // 继续尝试其他方法\n        }\n      }\n      \n      // 如果仍未找到有效范围，尝试查找一般可编辑元素\n      if (!currentSelection || !currentSelection.range) {\n        console.log('尝试查找一般可编辑元素');\n        \n        // 查找常见的编辑器元素\n        const editableElements = document.querySelectorAll('[contenteditable=\"true\"], textarea, input[type=\"text\"]');\n        let targetElement = null;\n        \n        // 查找焦点元素\n        Array.from(editableElements).forEach(el => {\n          if (el === document.activeElement) {\n            targetElement = el;\n            console.log('找到焦点可编辑元素');\n          }\n        });\n        \n        // 如果没有找到焦点元素，使用第一个可编辑元素\n        if (!targetElement && editableElements.length > 0) {\n          targetElement = editableElements[0];\n          console.log('使用第一个可编辑元素');\n        }\n        \n        // 创建范围\n        const range = document.createRange();\n        \n        if (targetElement) {\n          try {\n            range.selectNodeContents(targetElement);\n            console.log('已选择可编辑元素内容');\n            \n            if (!currentSelection) {\n              currentSelection = { text, range };\n            } else {\n              currentSelection.range = range;\n            }\n          } catch (e) {\n            console.debug('无法选择可编辑元素内容，创建虚拟范围处理', e);\n            createVirtualRange();\n          }\n        } else {\n          console.debug('未找到可编辑元素，创建虚拟范围处理');\n          createVirtualRange();\n        }\n      }\n    }\n  }\n  \n  // 创建虚拟范围的辅助函数\n  function createVirtualRange() {\n    // 创建一个临时元素作为范围的容器\n    const tempDiv = document.createElement('div');\n    tempDiv.style.position = 'absolute';\n    tempDiv.style.left = '-9999px';\n    tempDiv.style.top = '-9999px';\n    tempDiv.textContent = text;\n    document.body.appendChild(tempDiv);\n    \n    const range = document.createRange();\n    range.selectNodeContents(tempDiv);\n    \n    console.log('已创建虚拟范围');\n    \n    if (!currentSelection) {\n      currentSelection = { text, range };\n    } else {\n      currentSelection.range = range;\n    }\n    \n    // 不立即移除临时元素，等待替换操作完成后再移除\n    // 将引用存储在全局变量中\n    window.tempRangeElement = tempDiv;\n  }\n\n  // 清除任何已存在的弹窗\n  if (popupElement && popupElement.parentNode) {\n    // 直接移除而不使用动画效果，避免闪现\n    popupElement.parentNode.removeChild(popupElement);\n    popupElement = null;\n    shadowRoot = null;\n    shadowHost = null;\n  }\n  \n  // 显示加载中弹窗\n  try {\n    // 延迟一点显示弹窗，确保DOM已经准备好\n    setTimeout(() => {\n      showLoadingPopup();\n      console.log('已显示加载中弹窗');\n    }, 50);\n  } catch (popupError) {\n    console.error('显示加载中弹窗失败:', popupError);\n    // 如果失败，再次延迟重试\n    setTimeout(() => {\n      try {\n        showLoadingPopup();\n        console.log('延迟重试显示加载中弹窗成功');\n      } catch (retryError) {\n        console.error('延迟重试显示加载中弹窗失败:', retryError);\n        // 如果仍然失败，无法继续\n      }\n    }, 150);\n  }\n\n  // 添加超时处理\n  const timeoutId = setTimeout(() => {\n    console.warn('请求超时，显示错误弹窗');\n    showErrorPopup('请求超时，请重试');\n  }, 30000); // 30秒超时\n\n  try {\n    console.log('发送消息到后台脚本');\n  // 发送消息到后台脚本\n  chrome.runtime.sendMessage(\n    {\n      type: 'OPTIMIZE_TEXT',\n      text\n    },\n      (response: OptimizeTextResponse | undefined) => {\n        // 清除超时\n        clearTimeout(timeoutId);\n        console.log('收到后台响应:', response);\n        \n        // 检查runtime.lastError\n        if (chrome.runtime.lastError) {\n          console.error('消息响应错误:', chrome.runtime.lastError.message);\n          showErrorPopup('通信错误: ' + chrome.runtime.lastError.message);\n          return;\n        }\n        \n        // 检查响应是否存在\n        if (!response) {\n          console.error('未收到有效响应');\n          showErrorPopup('未收到有效响应，请重试');\n          return;\n        }\n        \n        if (response.success && response.optimizedText) {\n          // 显示优化结果弹窗\n          console.log('显示优化结果弹窗');\n          \n          // 清除任何已存在的弹窗\n          if (popupElement && popupElement.parentNode) {\n            // 直接移除而不使用动画效果，避免闪现\n            popupElement.parentNode.removeChild(popupElement);\n            popupElement = null;\n            shadowRoot = null;\n            shadowHost = null;\n          }\n          \n          // 延迟一点显示结果弹窗，避免闪现\n          setTimeout(() => {\n            try {\n              showResultPopup(text, response.optimizedText || \"\", response.stats);\n              console.log('显示结果弹窗成功');\n            } catch (resultError) {\n              console.error('显示结果弹窗失败:', resultError);\n              \n              // 如果失败，再次延迟重试\n              setTimeout(() => {\n                try {\n                  showResultPopup(text, response.optimizedText || \"\", response.stats);\n                  console.log('延迟重试显示结果弹窗成功');\n                } catch (retryError) {\n                  console.error('延迟重试显示结果弹窗失败:', retryError);\n                  alert('优化成功，但无法显示结果弹窗。请刷新页面后重试。');\n                }\n              }, 150);\n            }\n          }, 50);\n        } else {\n          // 显示错误弹窗，包含详细信息\n          const errorMessage = response.error || '优化失败，请重试';\n          const errorDetails = response.details ? `\\n\\n详细信息: ${response.details}` : '';\n          console.error('优化失败:', errorMessage, errorDetails);\n          \n          // 如果是API配置错误，提供更具体的指导\n          if (errorMessage.includes('API配置可能有误') || errorMessage.includes('API未配置')) {\n            showApiConfigErrorPopup(errorMessage, errorDetails);\n          } else {\n            showErrorPopup(errorMessage + errorDetails);\n          }\n        }\n      }\n    );\n  } catch (error) {\n    // 清除超时\n    clearTimeout(timeoutId);\n    \n    // 处理异常\n    console.error('发送请求失败:', error);\n    showErrorPopup('发送请求失败: ' + (error instanceof Error ? error.message : String(error)));\n  }\n}\n\n// 显示加载中弹窗\nfunction showLoadingPopup(): void {\n  // 如果已有弹窗，先移除\n  removePopup();\n\n  // 创建弹窗元素\n  popupElement = document.createElement('div');\n  popupElement.className = 'longport-ai-popup';\n  popupElement.style.zIndex = '2147483647'; // 最大z-index值\n  \n  // 弹窗头部\n  const header = document.createElement('div');\n  header.className = 'longport-ai-popup-header';\n  \n  const title = document.createElement('h3');\n  title.className = 'longport-ai-popup-title';\n  title.textContent = 'LongPort AI';\n  \n  const closeButton = document.createElement('button');\n  closeButton.className = 'longport-ai-popup-close';\n  closeButton.innerHTML = '';  // 使用CSS伪元素来添加X符号\n  closeButton.addEventListener('click', removePopup);\n  \n  header.appendChild(title);\n  header.appendChild(closeButton);\n  \n  // 弹窗内容\n  const content = document.createElement('div');\n  content.className = 'longport-ai-loading';\n  \n  const spinner = document.createElement('div');\n  spinner.className = 'longport-ai-spinner';\n  \n  const loadingText = document.createElement('p');\n  loadingText.className = 'longport-ai-loading-text';\n  loadingText.textContent = '正在润色文本...';\n  \n  content.appendChild(spinner);\n  content.appendChild(loadingText);\n  \n  // 组装弹窗\n  popupElement.appendChild(header);\n  popupElement.appendChild(content);\n  \n  // 添加到页面前设置初始样式\n  popupElement.style.opacity = '0';\n  \n  // 智能定位弹窗\n  positionPopupIntelligently();\n  \n  document.body.appendChild(popupElement);\n  \n  // 设置拖拽功能\n  makeElementDraggable(popupElement, header);\n  \n  // 添加动画效果\n  setTimeout(() => {\n    if (popupElement) {\n      popupElement.style.opacity = '1';\n    }\n  }, 10);\n  \n  console.log('弹窗已创建并添加到DOM');\n}\n\n// 智能定位弹窗\nfunction positionPopupIntelligently(): void {\n  if (!popupElement) {\n    console.log('无法智能定位弹窗：缺少弹窗元素');\n    return;\n  }\n  \n  // 如果没有选中区域或范围，则居中显示\n  if (!currentSelection || !currentSelection.range) {\n    console.log('无选中区域，居中显示弹窗');\n    popupElement.style.top = '50%';\n    popupElement.style.left = '50%';\n    popupElement.style.transform = 'translate(-50%, -50%)';\n    return;\n  }\n  \n  try {\n    // 获取选中文本的范围\n    const selectionRect = currentSelection.range.getBoundingClientRect();\n    const popupWidth = 450; // 弹窗默认宽度\n    const popupHeight = 300; // 弹窗默认高度估计值\n    \n    // 获取视口尺寸\n    const viewportWidth = window.innerWidth;\n    const viewportHeight = window.innerHeight;\n    const scrollY = window.scrollY || window.pageYOffset;\n    \n    // 默认尝试显示在选中文本下方\n    let top = selectionRect.bottom + 10 + scrollY; // 选中文本底部加10px间距，考虑滚动位置\n    let left = selectionRect.left + (selectionRect.width / 2); // 水平居中\n    let transformValue = 'translate(-50%, 0)';\n    \n    // 检查下方空间是否足够\n    if (selectionRect.bottom + popupHeight > viewportHeight) {\n      // 下方空间不足，尝试显示在选中文本上方\n      top = selectionRect.top - popupHeight - 10 + scrollY; // 选中文本顶部减去弹窗高度再减10px间距\n      \n      // 检查上方空间是否足够\n      if (selectionRect.top - popupHeight < 0) {\n        // 上下方都空间不足，居中显示\n        console.log('上下方都空间不足，居中显示弹窗');\n        popupElement.style.top = `${viewportHeight / 2 + scrollY}px`;\n        popupElement.style.left = '50%';\n        popupElement.style.transform = 'translate(-50%, -50%)';\n        return;\n      } else {\n        console.log('在选中文本上方显示弹窗');\n        transformValue = 'translate(-50%, 0)';\n      }\n    } else {\n      console.log('在选中文本下方显示弹窗');\n      transformValue = 'translate(-50%, 0)';\n    }\n    \n    // 确保弹窗水平方向不超出视口\n    if (left - (popupWidth / 2) < 20) {\n      left = 20 + (popupWidth / 2); // 靠左对齐，保的20px边距\n    } else if (left + (popupWidth / 2) > viewportWidth - 20) {\n      left = viewportWidth - 20 - (popupWidth / 2); // 靠右对齐，保的20px边距\n    }\n    \n    // 设置弹窗位置\n    popupElement.style.top = `${top}px`;\n    popupElement.style.left = `${left}px`;\n    popupElement.style.transform = transformValue;\n  } catch (error) {\n    console.error('智能定位弹窗失败:', error);\n    // 如果失败，回退到默认中心定位\n    popupElement.style.top = '50%';\n    popupElement.style.left = '50%';\n    popupElement.style.transform = 'translate(-50%, -50%)';\n  }\n}\n\n// 显示结果弹窗\nfunction showResultPopup(originalText: string, optimizedText: string, stats?: { originalLength: number; optimizedLength: number }): void {\n  // 如果已有弹窗，先移除\n  removePopup();\n\n  // 创建弹窗元素\n  popupElement = document.createElement('div');\n  popupElement.className = 'longport-ai-popup';\n  popupElement.style.zIndex = '2147483647'; // 最大z-index值\n  popupElement.style.opacity = '0'; // 初始透明，等待动画效果\n  \n  // 弹窗头部\n  const header = document.createElement('div');\n  header.className = 'longport-ai-popup-header';\n  \n  const title = document.createElement('h3');\n  title.className = 'longport-ai-popup-title';\n  title.textContent = 'LongPort AI';\n  \n  const closeButton = document.createElement('button');\n  closeButton.className = 'longport-ai-popup-close';\n  closeButton.innerHTML = '';  // 使用CSS伪元素来添加X符号\n  closeButton.addEventListener('click', removePopup);\n  \n  header.appendChild(title);\n  header.appendChild(closeButton);\n  \n  // 弹窗内容\n  const content = document.createElement('div');\n  content.className = 'longport-ai-popup-content';\n  \n  // 创建文本容器\n  const textContainer = document.createElement('div');\n  textContainer.className = 'longport-ai-text-container';\n  \n  // 优化后文本部分\n  const optimizedSection = document.createElement('div');\n  optimizedSection.className = 'longport-ai-text-section';\n  \n  const optimizedTextarea = document.createElement('textarea');\n  optimizedTextarea.className = 'longport-ai-text-area longport-ai-optimized';\n  optimizedTextarea.value = optimizedText;\n  optimizedTextarea.readOnly = true;\n  \n  optimizedSection.appendChild(optimizedTextarea);\n  \n  // 添加到文本容器\n  textContainer.appendChild(optimizedSection);\n  \n  // 字数统计信息\n  const statsElement = document.createElement('div');\n  statsElement.className = 'longport-ai-stats';\n  \n  if (stats) {\n    // 类型断言为扩展的统计类型\n    const extendedStats = stats as {\n      originalLength: number;\n      optimizedLength: number;\n      lengthDifference?: number;\n      percentageChange?: number;\n      originalChineseChars?: number;\n      optimizedChineseChars?: number;\n      originalEnglishWords?: number;\n      optimizedEnglishWords?: number;\n    };\n    \n    // 创建统计信息容器\n    const statsContainer = document.createElement('div');\n    statsContainer.className = 'longport-ai-stats-container';\n    \n    // 基本字数统计部分\n    const basicStatsDiv = document.createElement('div');\n    basicStatsDiv.className = 'longport-ai-stats-row';\n    \n    // 只显示字数变化\n    const changeStats = document.createElement('div');\n    changeStats.className = 'longport-ai-stats-item';\n    \n    // 使用API返回的变化量，如果没有则计算\n    const changeAmount = extendedStats.lengthDifference !== undefined ? \n      extendedStats.lengthDifference : \n      stats.optimizedLength - stats.originalLength;\n    \n    // 只显示变化量，不显示百分比\n    const changeText = changeAmount > 0 ? \n      `+${changeAmount}` : \n      `${changeAmount}`;\n    \n    // 将字数变化显示在一行\n    changeStats.innerHTML = `<span class=\"longport-ai-stats-label\">字数变化：</span><span class=\"longport-ai-stats-change ${changeAmount >= 0 ? 'longport-ai-positive' : 'longport-ai-negative'}\">${changeText}</span>`;\n    \n    // 添加字数变化到行\n    basicStatsDiv.appendChild(changeStats);\n    \n    // 添加基本统计到容器\n    statsContainer.appendChild(basicStatsDiv);\n    \n    // 不显示详细的中英文统计\n    \n    // 添加统计容器到主元素\n    statsElement.appendChild(statsContainer);\n    \n    // 保存优化记录\n    saveOptimizationRecord(originalText, optimizedText, stats);\n  }\n  \n  content.appendChild(textContainer);\n  content.appendChild(statsElement);\n  \n  // 弹窗底部\n  const footer = document.createElement('div');\n  footer.className = 'longport-ai-popup-footer';\n  \n  const cancelButton = document.createElement('button');\n  cancelButton.className = 'longport-ai-btn longport-ai-btn-default';\n  cancelButton.textContent = '取消';\n  cancelButton.addEventListener('click', removePopup);\n  \n  const replaceButton = document.createElement('button');\n  replaceButton.className = 'longport-ai-btn longport-ai-btn-primary';\n  replaceButton.textContent = '替换';\n  replaceButton.addEventListener('click', () => {\n    replaceSelectedText(optimizedText);\n    removePopup();\n  });\n  \n  footer.appendChild(cancelButton);\n  footer.appendChild(replaceButton);\n  \n  // 组装弹窗\n  popupElement.appendChild(header);\n  popupElement.appendChild(content);\n  popupElement.appendChild(footer);\n  \n  // 智能定位弹窗\n  positionPopupIntelligently();\n  \n  // 添加到页面\n  document.body.appendChild(popupElement);\n  \n  // 设置拖拽功能\n  makeElementDraggable(popupElement, header);\n  \n  // 添加动画效果\n  setTimeout(() => {\n    if (popupElement) {\n      popupElement.style.opacity = '1';\n    }\n  }, 10);\n}\n\n// 显示API配置错误弹窗\nfunction showApiConfigErrorPopup(errorMessage: string, errorDetails: string): void {\n  // 清除任何已存在的弹窗\n  if (popupElement && popupElement.parentNode) {\n    // 直接移除而不使用动画效果，避免闪现\n    popupElement.parentNode.removeChild(popupElement);\n    popupElement = null;\n    shadowRoot = null;\n    shadowHost = null;\n  }\n  \n  // 调试日志\n  console.log('显示API配置错误弹窗:', errorMessage);\n\n  // 创建弹窗元素\n  popupElement = document.createElement('div');\n  popupElement.className = 'longport-ai-popup';\n  popupElement.style.zIndex = '2147483647'; // 最大z-index值\n  \n  // 弹窗头部\n  const header = document.createElement('div');\n  header.className = 'longport-ai-popup-header';\n  \n  const title = document.createElement('h3');\n  title.className = 'longport-ai-popup-title';\n  title.textContent = 'longPort AI - API配置';\n  \n  const closeButton = document.createElement('button');\n  closeButton.className = 'longport-ai-popup-close';\n  closeButton.innerHTML = '';  // 使用CSS伪元素来添加X符号\n  closeButton.addEventListener('click', removePopup);\n  \n  header.appendChild(title);\n  header.appendChild(closeButton);\n  \n  // 弹窗内容\n  const content = document.createElement('div');\n  content.className = 'longport-ai-popup-content';\n  \n  const errorElement = document.createElement('div');\n  errorElement.className = 'longport-ai-error';\n  \n  // 显示错误信息\n  const errorTitle = document.createElement('div');\n  errorTitle.className = 'longport-ai-error-title';\n  errorTitle.textContent = '需要配置API或使用模拟API';\n  errorElement.appendChild(errorTitle);\n  \n  // API配置错误详细信息\n  const errorDetailsElement = document.createElement('div');\n  errorDetailsElement.className = 'longport-ai-error-details';\n  errorDetailsElement.innerHTML = `\n    <p>您的API配置可能有误或未配置。您可以：</p>\n    <ul>\n      <li>配置正确的API地址和密钥</li>\n      <li>或使用模拟API进行文本优化</li>\n    </ul>\n  `;\n  errorElement.appendChild(errorDetailsElement);\n  \n  // 按钮容器\n  const buttonsContainer = document.createElement('div');\n  buttonsContainer.style.display = 'flex';\n  buttonsContainer.style.justifyContent = 'space-between';\n  buttonsContainer.style.marginTop = '16px';\n  \n  // 配置API按钮\n  const configApiButton = document.createElement('button');\n  configApiButton.className = 'longport-ai-btn longport-ai-btn-primary';\n  configApiButton.textContent = '配置API';\n  configApiButton.style.marginRight = '8px';\n  configApiButton.addEventListener('click', () => {\n    chrome.runtime.openOptionsPage();\n    removePopup();\n  });\n  \n  // 使用模拟API按钮\n  const useMockApiButton = document.createElement('button');\n  useMockApiButton.className = 'longport-ai-btn longport-ai-btn-default';\n  useMockApiButton.textContent = '使用模拟API';\n  useMockApiButton.addEventListener('click', () => {\n    // 发送消息到后台脚本，使用模拟API\n    chrome.runtime.sendMessage(\n      {\n        type: 'OPTIMIZE_TEXT',\n        text: currentSelection?.text || '',\n        useMockApi: true\n    },\n    (response) => {\n        if (response && response.success && response.optimizedText) {\n          removePopup();\n          showResultPopup(currentSelection?.text || '', response.optimizedText, response.stats);\n        } else {\n          showErrorPopup('使用模拟API失败，请重试');\n        }\n      }\n    );\n  });\n  \n  buttonsContainer.appendChild(configApiButton);\n  buttonsContainer.appendChild(useMockApiButton);\n  errorElement.appendChild(buttonsContainer);\n  \n  content.appendChild(errorElement);\n  \n  // 弹窗底部\n  const footer = document.createElement('div');\n  footer.className = 'longport-ai-popup-footer';\n  \n  const closeBtn = document.createElement('button');\n  closeBtn.className = 'longport-ai-btn longport-ai-btn-default';\n  closeBtn.textContent = '关闭';\n  closeBtn.addEventListener('click', removePopup);\n  \n  footer.appendChild(closeBtn);\n  \n  // 组装弹窗\n  popupElement.appendChild(header);\n  popupElement.appendChild(content);\n  popupElement.appendChild(footer);\n  \n  // 智能定位弹窗\n  positionPopupIntelligently();\n  \n  // 添加到页面\n  document.body.appendChild(popupElement);\n  \n  // 设置拖拽功能\n  makeElementDraggable(popupElement, header);\n  \n  // 添加动画效果\n  setTimeout(() => {\n    if (popupElement) {\n      popupElement.style.opacity = '1';\n    }\n  }, 10);\n}\n\n// 显示错误弹窗\nfunction showErrorPopup(errorMessage: string): void {\n  // 清除任何已存在的弹窗\n  if (popupElement && popupElement.parentNode) {\n    // 直接移除而不使用动画效果，避免闪现\n    popupElement.parentNode.removeChild(popupElement);\n    popupElement = null;\n    shadowRoot = null;\n    shadowHost = null;\n  }\n  \n  // 调试日志\n  console.log('显示错误弹窗:', errorMessage);\n\n  // 创建弹窗元素\n  popupElement = document.createElement('div');\n  popupElement.className = 'longport-ai-popup';\n  popupElement.style.zIndex = '2147483647'; // 最大z-index值\n  \n  // 弹窗头部\n  const header = document.createElement('div');\n  header.className = 'longport-ai-popup-header';\n  \n  const title = document.createElement('h3');\n  title.className = 'longport-ai-popup-title';\n  title.textContent = 'LongPort AI - 错误';\n  \n  const closeButton = document.createElement('button');\n  closeButton.className = 'longport-ai-popup-close';\n  closeButton.innerHTML = '';  // 使用CSS伪元素来添加X符号\n  closeButton.addEventListener('click', removePopup);\n  \n  header.appendChild(title);\n  header.appendChild(closeButton);\n  \n  // 弹窗内容\n  const content = document.createElement('div');\n  content.className = 'longport-ai-popup-content';\n  \n  const errorElement = document.createElement('div');\n  errorElement.className = 'longport-ai-error';\n  \n  // 显示错误信息\n  const errorTitle = document.createElement('div');\n  errorTitle.className = 'longport-ai-error-title';\n  errorTitle.textContent = errorMessage;\n  errorElement.appendChild(errorTitle);\n  \n  // 处理不同类型的错误\n  if (errorMessage.includes('API 未配置') || errorMessage.includes('API_NOT_CONFIGURED')) {\n    // API未配置错误\n    const settingsButton = document.createElement('button');\n    settingsButton.className = 'longport-ai-btn longport-ai-btn-primary';\n    settingsButton.style.marginTop = '12px';\n    settingsButton.textContent = '前往设置';\n    settingsButton.addEventListener('click', () => {\n      chrome.runtime.openOptionsPage();\n      removePopup();\n    });\n    \n    errorElement.appendChild(document.createElement('br'));\n    errorElement.appendChild(settingsButton);\n  } \n  else if (errorMessage.includes('网络') || errorMessage.includes('连接')) {\n    // 网络连接错误\n    const errorDetails = document.createElement('div');\n    errorDetails.className = 'longport-ai-error-details';\n    errorDetails.innerHTML = `\n      <p>无法连接到API服务器，请检查：</p>\n      <ul>\n        <li>您的网络连接是否正常</li>\n        <li>API服务器是否可用</li>\n        <li>API地址是否正确</li>\n      </ul>\n    `;\n    errorElement.appendChild(errorDetails);\n    \n    const retryButton = document.createElement('button');\n    retryButton.className = 'longport-ai-btn longport-ai-btn-primary';\n    retryButton.style.marginTop = '12px';\n    retryButton.textContent = '重试';\n    retryButton.addEventListener('click', () => {\n      removePopup();\n      // 如果有保存的文本，重试优化\n      if (currentSelection && currentSelection.text) {\n        const textToOptimize = currentSelection.text;\n        setTimeout(() => optimizeText(textToOptimize), 100);\n      }\n    });\n    \n    errorElement.appendChild(retryButton);\n  }\n  \n  content.appendChild(errorElement);\n  \n  // 弹窗底部\n  const footer = document.createElement('div');\n  footer.className = 'longport-ai-popup-footer';\n  \n  const closeBtn = document.createElement('button');\n  closeBtn.className = 'longport-ai-btn longport-ai-btn-default';\n  closeBtn.textContent = '关闭';\n  closeBtn.addEventListener('click', removePopup);\n  \n  footer.appendChild(closeBtn);\n  \n  // 组装弹窗\n  popupElement.appendChild(header);\n  popupElement.appendChild(content);\n  popupElement.appendChild(footer);\n  \n  // 智能定位弹窗\n  positionPopupIntelligently();\n  \n  // 添加到页面\n  document.body.appendChild(popupElement);\n  \n  // 设置拖拽功能\n  makeElementDraggable(popupElement, header);\n  \n  // 添加动画效果\n  setTimeout(() => {\n    if (popupElement) {\n      popupElement.style.opacity = '1';\n    }\n  }, 10);\n}\n\n// 移除弹窗\nfunction removePopup(): void {\n  if (popupElement && popupElement.parentNode) {\n    // 添加淡出动画\n    popupElement.style.opacity = '0';\n    popupElement.style.transform = 'translate(-50%, -50%) scale(0.95)';\n    \n    // 等待动画完成后移除\n    setTimeout(() => {\n      if (popupElement && popupElement.parentNode) {\n        popupElement.parentNode.removeChild(popupElement);\n        popupElement = null;\n      }\n    }, 200);\n  }\n}\n\n// 显示Toast消息\nfunction showToast(message: string, type: 'success' | 'error' = 'success', duration: number = 3000): void {\n  // 创建Toast元素\n  const toast = document.createElement('div');\n  toast.className = `longport-ai-toast longport-ai-toast-${type}`;\n  \n  // 创建内容\n  const content = document.createElement('div');\n  content.className = 'longport-ai-toast-content';\n  content.textContent = message;\n  \n  toast.appendChild(content);\n  \n  // 添加到页面\n  document.body.appendChild(toast);\n  \n  // 设置自动消失\n  setTimeout(() => {\n    if (toast.parentNode) {\n      toast.parentNode.removeChild(toast);\n    }\n  }, duration);\n}\n\n// 使用剪贴板复制文本的辅助函数\nfunction copyToClipboard(text: string): Promise<void> {\n  return navigator.clipboard.writeText(text)\n    .then(() => {\n      showToast('文本已复制到剪贴板，请手动粘贴', 'success');\n    })\n    .catch(error => {\n      console.error('复制到剪贴板失败:', error);\n      showToast('无法复制到剪贴板: ' + (error instanceof Error ? error.message : String(error)), 'error');\n      throw error; // 重新抛出错误以便调用者处理\n    });\n}\n\n// 替换选中文本\nfunction replaceSelectedText(newText: string): void {\n  if (!currentSelection) {\n    console.error('没有可替换的文本');\n    showToast('没有可替换的文本', 'error');\n    return;\n  }\n\n  try {\n    // 检查是否使用了虚拟范围（临时元素）\n    if (window.tempRangeElement) {\n      console.log('检测到虚拟范围，使用剪贴板替代');\n      \n      // 使用剪贴板 API\n      copyToClipboard(newText)\n        .then(() => {\n          // 清理临时元素\n          if (window.tempRangeElement && window.tempRangeElement.parentNode) {\n            window.tempRangeElement.parentNode.removeChild(window.tempRangeElement);\n            window.tempRangeElement = undefined;\n          }\n        })\n        .catch(() => {\n          // 错误已在 copyToClipboard 中处理\n        });\n      \n      return;\n    }\n    \n    // 确保有有效的范围\n    if (!currentSelection.range) {\n      console.error('没有有效的范围');\n      showToast('没有有效的范围，无法替换文本', 'error');\n      return;\n    }\n\n    // 检查目标元素是否是可编辑元素\n    const containerElement = currentSelection.range.commonAncestorContainer;\n    const isEditable = isEditableElement(containerElement);\n    \n    // 尝试检测 Notion 编辑器\n    const isNotionEditor = containerElement && \n      (containerElement.parentElement?.className.includes('notion') || \n       containerElement.parentElement?.parentElement?.className.includes('notion'));\n       \n    if (isNotionEditor) {\n      console.log('检测到 Notion 编辑器，尝试特殊处理');\n      \n      // 尝试使用 Notion 特定的方法\n      try {\n        // 先尝试常规方法\n        const textNode = document.createTextNode(newText);\n        currentSelection.range.deleteContents();\n        currentSelection.range.insertNode(textNode);\n        \n        // 创建新的范围选择插入的文本\n        const selection = window.getSelection();\n        if (selection && textNode.parentNode) {\n          const range = document.createRange();\n          range.selectNodeContents(textNode);\n          selection.removeAllRanges();\n          selection.addRange(range);\n          \n          // 延迟显示成功消息，确保替换和选中都已完成\n          setTimeout(() => {\n            showToast('文本替换成功', 'success');\n          }, 100);\n        } else {\n          showToast('文本替换成功', 'success');\n        }\n      } catch (notionError) {\n        console.error('Notion 编辑器替换失败:', notionError);\n        \n        // 尝试使用 execCommand 方法（对某些编辑器更有效）\n        try {\n          document.execCommand('insertText', false, newText);\n          showToast('文本替换成功', 'success');\n        } catch (execError) {\n          console.error('execCommand 替换失败:', execError);\n          \n          // 回退到剪贴板方法\n          copyToClipboard(newText).catch(() => {\n            // 错误已在 copyToClipboard 中处理\n            showToast('无法替换文本，也无法复制到剪贴板', 'error');\n          });\n        }\n      }\n    }\n    else if (isEditable) {\n      console.log('在可编辑元素中替换文本');\n      \n      // 尝试使用 execCommand 方法（对某些编辑器更有效）\n      try {\n        const success = document.execCommand('insertText', false, newText);\n        if (success) {\n          // 显示成功消息\n          showToast('文本替换成功', 'success');\n          return;\n        }\n      } catch (execError) {\n        console.log('execCommand 方法失败，尝试使用 DOM API:', execError);\n      }\n      \n      // 创建一个新的文本节点\n      const textNode = document.createTextNode(newText);\n      \n      // 删除选中的内容\n      currentSelection.range.deleteContents();\n      \n      // 插入新的文本节点\n      currentSelection.range.insertNode(textNode);\n      \n      // 创建新的范围选择插入的文本\n      const selection = window.getSelection();\n      if (selection && textNode.parentNode) {\n        const range = document.createRange();\n        range.selectNodeContents(textNode);\n        selection.removeAllRanges();\n        selection.addRange(range);\n      }\n      \n      // 延迟显示成功消息，确保替换和选中都已完成\n      setTimeout(() => {\n        showToast('文本替换成功', 'success');\n      }, 100);\n    } else {\n      // 对于不可编辑元素，尝试使用 clipboard API\n      console.log('目标不是可编辑元素，尝试使用剪贴板');\n      \n      // 将优化后的文本复制到剪贴板\n      copyToClipboard(newText).catch(() => {\n        // 错误已在 copyToClipboard 中处理\n      });\n    }\n  } catch (error) {\n    console.error('替换文本失败:', error);\n    \n    // 尝试使用剪贴板作为备用方案\n    copyToClipboard(newText).catch(() => {\n      // 如果剪贴板也失败，显示原始错误\n      showToast('替换文本失败: ' + (error instanceof Error ? error.message : String(error)), 'error');\n    });\n  } finally {\n    // 清理临时元素（如果有）\n    if (window.tempRangeElement && window.tempRangeElement.parentNode) {\n      window.tempRangeElement.parentNode.removeChild(window.tempRangeElement);\n      window.tempRangeElement = undefined;\n    }\n  }\n}\n\n// 检查元素是否可编辑\nfunction isEditableElement(node: Node | null): boolean {\n  if (!node) return false;\n  \n  // 如果是文本节点，检查其父元素\n  if (node.nodeType === Node.TEXT_NODE) {\n    return isEditableElement(node.parentNode);\n  }\n  \n  // 如果是元素节点\n  if (node.nodeType === Node.ELEMENT_NODE) {\n    const element = node as Element;\n    \n    // 检查是否是可编辑元素\n    if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {\n      return true;\n    }\n    \n    // 检查是否有 contentEditable 属性\n    if (element.getAttribute('contenteditable') === 'true') {\n      return true;\n    }\n    \n    // 递归检查父元素\n    return isEditableElement(element.parentNode);\n  }\n  \n  return false;\n}\n\n// 使元素可拖拽\nfunction makeElementDraggable(element: HTMLElement, dragHandle: HTMLElement): void {\n  let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;\n  \n  dragHandle.onmousedown = dragMouseDown;\n  \n  function dragMouseDown(e: MouseEvent): void {\n    e.preventDefault();\n    // 获取鼠标初始位置\n    pos3 = e.clientX;\n    pos4 = e.clientY;\n    // 添加拖拽中的视觉反馈\n    element.classList.add('longport-ai-dragging');\n    // 添加事件监听\n    document.onmouseup = closeDragElement;\n    document.onmousemove = elementDrag;\n  }\n  \n  function elementDrag(e: MouseEvent): void {\n    e.preventDefault();\n    // 计算新位置\n    pos1 = pos3 - e.clientX;\n    pos2 = pos4 - e.clientY;\n    pos3 = e.clientX;\n    pos4 = e.clientY;\n    // 设置元素新位置\n    element.style.top = (element.offsetTop - pos2) + \"px\";\n    element.style.left = (element.offsetLeft - pos1) + \"px\";\n    // 移除默认的 transform\n    element.style.transform = 'none';\n  }\n  \n  function closeDragElement(): void {\n    // 移除拖拽中的视觉反馈\n    element.classList.remove('longport-ai-dragging');\n    // 移除事件监听\n    document.onmouseup = null;\n    document.onmousemove = null;\n  }\n}\n\n/**\n * 保存优化记录到本地存储\n */\nasync function saveOptimizationRecord(originalText: string, optimizedText: string, stats: { originalLength: number; optimizedLength: number }): Promise<void> {\n  try {\n    // 获取当前页面信息\n    const sourceUrl = window.location.href;\n    const sourceDomain = window.location.hostname;\n    \n    // 获取优化模式（默认为基础模式）\n    const getOptimizationMode = async (): Promise<OptimizationMode> => {\n      return new Promise((resolve) => {\n        chrome.storage.sync.get(['strictMode'], (items) => {\n          const isStrictMode = items.strictMode as boolean;\n          resolve(isStrictMode ? OptimizationMode.STRICT : OptimizationMode.BASIC);\n        });\n      });\n    };\n    \n    const mode = await getOptimizationMode();\n    \n    // 计算统计信息\n    const changeAmount = stats.optimizedLength - stats.originalLength;\n    const percentageChange = stats.originalLength > 0 \n      ? Math.round((changeAmount / stats.originalLength) * 100) \n      : 0;\n    \n    // 创建优化统计信息对象\n    const optimizationStats = {\n      originalLength: stats.originalLength,\n      optimizedLength: stats.optimizedLength,\n      lengthDifference: changeAmount,\n      percentageChange: percentageChange,\n      processingTime: 0 // 不记录处理时间，因为这里无法获取\n    };\n    \n    // 保存记录\n    await recordManager.saveRecord({\n      sourceUrl,\n      sourceDomain,\n      originalText,\n      optimizedText,\n      mode,\n      stats: optimizationStats\n    });\n    \n    console.log('优化记录已保存');\n  } catch (error) {\n    console.error('保存优化记录失败:', error);\n    // 记录保存失败不影响主流程，所以不抛出异常\n  }\n}\n\n// 导出一个空对象，确保这是一个有效的模块\nexport {};"],"names":[],"sourceRoot":""}