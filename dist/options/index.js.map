{"version":3,"file":"options/index.js","mappings":";;;;;;;;;;;AAAA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;;AAEA;AAEA;AA+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://longport-ai/./src/options/options.css?9064","webpack://longport-ai/webpack/bootstrap","webpack://longport-ai/webpack/runtime/make namespace object","webpack://longport-ai/./src/options/index.ts"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * LongPort AI 助手 - 选项页脚本\n */\n\nimport './options.css';\n\n// 定义快捷键接口\ninterface Shortcut {\n  key: string;\n  altKey: boolean;\n  ctrlKey: boolean;\n  shiftKey: boolean;\n  metaKey: boolean;\n}\n\n// 定义设置接口\ninterface Settings {\n  apiEndpoint: string;\n  apiKey: string;\n  modelSelection: string; // 新增：模型选择\n  strictMode: boolean;\n  shortcuts: {\n    optimize: Shortcut; // 润色一下快捷键\n    replace: Shortcut;  // 替换快捷键\n  };\n}\n\n// 定义API测试响应接口\ninterface ApiTestResponse {\n  success: boolean;\n  message: string;\n  responseTime?: number;\n  details?: string;\n}\n\n// 默认设置\nconst defaultSettings: Settings = {\n  apiEndpoint: 'https://lboneapi.longbridge-inc.com', // 默认API地址\n  apiKey: '',\n  modelSelection: 'auto', // 默认自动模式\n  strictMode: false,\n  shortcuts: {\n    optimize: {\n      key: 'O',           // 默认Alt+O\n      altKey: true,\n      ctrlKey: false,\n      shiftKey: false,\n      metaKey: false\n    },\n    replace: {\n      key: ' ',           // 默认空格键\n      altKey: false,\n      ctrlKey: false,\n      shiftKey: false,\n      metaKey: false\n    }\n  }\n};\n\n// 常见浏览器快捷键，用于冲突检测\nconst commonBrowserShortcuts = [\n  { key: 'F', ctrlKey: true, shiftKey: false, altKey: false, metaKey: false }, // Ctrl+F (查找)\n  { key: 'P', ctrlKey: true, shiftKey: false, altKey: false, metaKey: false }, // Ctrl+P (打印)\n  { key: 'S', ctrlKey: true, shiftKey: false, altKey: false, metaKey: false }, // Ctrl+S (保存)\n  { key: 'T', ctrlKey: true, shiftKey: false, altKey: false, metaKey: false }, // Ctrl+T (新标签页)\n  { key: 'W', ctrlKey: true, shiftKey: false, altKey: false, metaKey: false }, // Ctrl+W (关闭标签页)\n  { key: 'N', ctrlKey: true, shiftKey: false, altKey: false, metaKey: false }, // Ctrl+N (新窗口)\n  { key: 'R', ctrlKey: true, shiftKey: false, altKey: false, metaKey: false }, // Ctrl+R (刷新)\n  { key: 'Tab', ctrlKey: true, shiftKey: false, altKey: false, metaKey: false }, // Ctrl+Tab (切换标签页)\n];\n\n// 格式化快捷键显示\nfunction formatShortcut(shortcut: Shortcut): string {\n  const parts = [];\n  \n  if (shortcut.ctrlKey) parts.push('Ctrl');\n  if (shortcut.altKey) parts.push('Alt');\n  if (shortcut.shiftKey) parts.push('Shift');\n  if (shortcut.metaKey) parts.push(navigator.platform.includes('Mac') ? '⌘' : 'Win');\n  \n  // 特殊按键显示处理\n  let keyDisplay = shortcut.key;\n  if (shortcut.key === ' ') keyDisplay = '空格';\n  if (shortcut.key === 'ArrowUp') keyDisplay = '↑';\n  if (shortcut.key === 'ArrowDown') keyDisplay = '↓';\n  if (shortcut.key === 'ArrowLeft') keyDisplay = '←';\n  if (shortcut.key === 'ArrowRight') keyDisplay = '→';\n  if (shortcut.key === 'Escape') keyDisplay = 'Esc';\n  \n  parts.push(keyDisplay);\n  return parts.join(' + ');\n}\n\n// 检查快捷键冲突\nfunction checkShortcutConflict(shortcut: Shortcut): string | null {\n  // 检查是否为空快捷键\n  if (!shortcut.key) {\n    return null;\n  }\n  \n  // 检查浏览器常用快捷键冲突\n  for (const browserShortcut of commonBrowserShortcuts) {\n    if (\n      shortcut.key === browserShortcut.key &&\n      shortcut.ctrlKey === browserShortcut.ctrlKey &&\n      shortcut.altKey === browserShortcut.altKey &&\n      shortcut.shiftKey === browserShortcut.shiftKey &&\n      shortcut.metaKey === browserShortcut.metaKey\n    ) {\n      return '与浏览器快捷键冲突';\n    }\n  }\n  \n  // 检查两个快捷键之间的冲突\n  const optimizeShortcut = currentSettings?.shortcuts?.optimize;\n  const replaceShortcut = currentSettings?.shortcuts?.replace;\n  \n  if (optimizeShortcut && replaceShortcut) {\n    // 检查优化快捷键和替换快捷键是否冲突\n    if (\n      shortcut !== optimizeShortcut &&\n      shortcut !== replaceShortcut &&\n      shortcut.key === optimizeShortcut.key &&\n      shortcut.ctrlKey === optimizeShortcut.ctrlKey &&\n      shortcut.altKey === optimizeShortcut.altKey &&\n      shortcut.shiftKey === optimizeShortcut.shiftKey &&\n      shortcut.metaKey === optimizeShortcut.metaKey\n    ) {\n      return '与润色文本快捷键冲突';\n    }\n    \n    if (\n      shortcut !== replaceShortcut &&\n      shortcut !== optimizeShortcut &&\n      shortcut.key === replaceShortcut.key &&\n      shortcut.ctrlKey === replaceShortcut.ctrlKey &&\n      shortcut.altKey === replaceShortcut.altKey &&\n      shortcut.shiftKey === replaceShortcut.shiftKey &&\n      shortcut.metaKey === replaceShortcut.metaKey\n    ) {\n      return '与替换文本快捷键冲突';\n    }\n  }\n  \n  return null;\n}\n\n// 当前设置\nlet currentSettings: Settings | null = null;\n\n// 更新快捷键显示\nfunction updateShortcutDisplay(type: 'optimize' | 'replace', shortcut: Shortcut): void {\n  const recorder = document.getElementById(`${type}ShortcutRecorder`);\n  const display = document.getElementById(`${type}ShortcutDisplay`);\n  const keyCombo = display?.querySelector('.shortcut-key-combo');\n  const placeholder = document.getElementById(`${type}ShortcutPlaceholder`);\n  const conflictElement = document.getElementById(`${type}ShortcutConflict`);\n  \n  if (!recorder || !display || !keyCombo || !placeholder || !conflictElement) return;\n  \n  // 检查是否有快捷键\n  if (shortcut && shortcut.key) {\n    // 显示快捷键\n    recorder.classList.add('has-shortcut');\n    \n    // 创建快捷键显示元素\n    keyCombo.innerHTML = '';\n    \n    // 添加修饰键\n    if (shortcut.ctrlKey || shortcut.altKey || shortcut.shiftKey || shortcut.metaKey) {\n      const modifiers = [];\n      if (shortcut.ctrlKey) modifiers.push('Ctrl');\n      if (shortcut.altKey) modifiers.push('Alt');\n      if (shortcut.shiftKey) modifiers.push('Shift');\n      if (shortcut.metaKey) modifiers.push(navigator.platform.includes('Mac') ? '⌘' : 'Win');\n      \n      modifiers.forEach((mod, index) => {\n        const modKey = document.createElement('span');\n        modKey.className = 'shortcut-key';\n        modKey.textContent = mod;\n        keyCombo.appendChild(modKey);\n        \n        if (index < modifiers.length - 1) {\n          const plus = document.createElement('span');\n          plus.className = 'shortcut-plus';\n          plus.textContent = '+';\n          keyCombo.appendChild(plus);\n        }\n      });\n      \n      // 添加加号\n      const plus = document.createElement('span');\n      plus.className = 'shortcut-plus';\n      plus.textContent = '+';\n      keyCombo.appendChild(plus);\n    }\n    \n    // 添加主键\n    const mainKey = document.createElement('span');\n    mainKey.className = 'shortcut-key';\n    \n    // 特殊按键显示处理\n    let keyDisplay = shortcut.key;\n    if (shortcut.key === ' ') keyDisplay = '空格';\n    if (shortcut.key === 'ArrowUp') keyDisplay = '↑';\n    if (shortcut.key === 'ArrowDown') keyDisplay = '↓';\n    if (shortcut.key === 'ArrowLeft') keyDisplay = '←';\n    if (shortcut.key === 'ArrowRight') keyDisplay = '→';\n    if (shortcut.key === 'Escape') keyDisplay = 'Esc';\n    \n    mainKey.textContent = keyDisplay;\n    keyCombo.appendChild(mainKey);\n    \n    // 检查冲突\n    const conflict = checkShortcutConflict(shortcut);\n    if (conflict) {\n      conflictElement.textContent = conflict;\n      conflictElement.classList.add('show');\n    } else {\n      conflictElement.classList.remove('show');\n    }\n  } else {\n    // 隐藏快捷键显示\n    recorder.classList.remove('has-shortcut');\n    conflictElement.classList.remove('show');\n  }\n}\n\n// 设置快捷键录入模式\nfunction setupShortcutRecorder(type: 'optimize' | 'replace'): void {\n  const recorder = document.getElementById(`${type}ShortcutRecorder`);\n  const clearBtn = document.getElementById(`${type}ShortcutClear`);\n  \n  if (!recorder || !clearBtn || !currentSettings) return;\n  \n  // 点击录入区域开始录入\n  recorder.addEventListener('click', () => {\n    // 添加录入中样式\n    recorder.classList.add('recording');\n    recorder.focus();\n    \n    // 显示提示\n    const placeholder = document.getElementById(`${type}ShortcutPlaceholder`);\n    if (placeholder) {\n      placeholder.textContent = '请按下快捷键...';\n    }\n  });\n  \n  // 按键事件处理\n  recorder.addEventListener('keydown', (e) => {\n    // 阻止默认行为\n    e.preventDefault();\n    \n    // 忽略单独的修饰键\n    if (['Control', 'Alt', 'Shift', 'Meta'].includes(e.key)) {\n      return;\n    }\n    \n    // 创建新的快捷键\n    const newShortcut: Shortcut = {\n      key: e.key,\n      ctrlKey: e.ctrlKey,\n      altKey: e.altKey,\n      shiftKey: e.shiftKey,\n      metaKey: e.metaKey\n    };\n    \n    // 更新当前设置\n    if (currentSettings) {\n      if (type === 'optimize') {\n        currentSettings.shortcuts.optimize = newShortcut;\n      } else {\n        currentSettings.shortcuts.replace = newShortcut;\n      }\n    }\n    \n    // 更新显示\n    updateShortcutDisplay(type, newShortcut);\n    \n    // 移除录入中样式\n    recorder.classList.remove('recording');\n    \n    // 失去焦点\n    recorder.blur();\n  });\n  \n  // 失去焦点时取消录入\n  recorder.addEventListener('blur', () => {\n    recorder.classList.remove('recording');\n    \n    // 恢复提示\n    const placeholder = document.getElementById(`${type}ShortcutPlaceholder`);\n    if (placeholder) {\n      placeholder.textContent = '点击此处录入快捷键';\n    }\n  });\n  \n  // 清除按钮\n  clearBtn.addEventListener('click', (e) => {\n    e.stopPropagation(); // 阻止事件冒泡\n    \n    // 创建空快捷键\n    const emptyShortcut: Shortcut = {\n      key: '',\n      ctrlKey: false,\n      altKey: false,\n      shiftKey: false,\n      metaKey: false\n    };\n    \n    // 更新当前设置\n    if (currentSettings) {\n      if (type === 'optimize') {\n        currentSettings.shortcuts.optimize = emptyShortcut;\n      } else {\n        currentSettings.shortcuts.replace = emptyShortcut;\n      }\n    }\n    \n    // 更新显示\n    updateShortcutDisplay(type, emptyShortcut);\n  });\n}\n\n// 加载设置\nfunction loadSettings(): void {\n  chrome.storage.sync.get(defaultSettings, (items) => {\n    const settings = items as unknown as Settings;\n    currentSettings = settings;\n    \n    // 填充表单\n    const apiEndpointInput = document.getElementById('apiEndpoint') as HTMLInputElement;\n    const apiKeyInput = document.getElementById('apiKey') as HTMLInputElement;\n    const modelSelectionSelect = document.getElementById('modelSelection') as HTMLSelectElement;\n    const strictModeCheckbox = document.getElementById('strictMode') as HTMLInputElement;\n    \n    if (apiEndpointInput) apiEndpointInput.value = settings.apiEndpoint;\n    if (apiKeyInput) apiKeyInput.value = settings.apiKey;\n    if (modelSelectionSelect) modelSelectionSelect.value = settings.modelSelection;\n    if (strictModeCheckbox) strictModeCheckbox.checked = settings.strictMode;\n    \n    // 填充快捷键设置\n    updateShortcutDisplay('optimize', settings.shortcuts.optimize);\n    updateShortcutDisplay('replace', settings.shortcuts.replace);\n  });\n}\n\n// 保存设置\nfunction saveSettings(): void {\n  const apiEndpointInput = document.getElementById('apiEndpoint') as HTMLInputElement;\n  const apiKeyInput = document.getElementById('apiKey') as HTMLInputElement;\n  const modelSelectionSelect = document.getElementById('modelSelection') as HTMLSelectElement;\n  const strictModeCheckbox = document.getElementById('strictMode') as HTMLInputElement;\n  \n  // 获取当前设置以保留快捷键设置\n  chrome.storage.sync.get(defaultSettings, (items) => {\n    const currentSettings = items as unknown as Settings;\n  \n  const settings: Settings = {\n    apiEndpoint: apiEndpointInput ? apiEndpointInput.value : '',\n    apiKey: apiKeyInput ? apiKeyInput.value : '',\n    modelSelection: modelSelectionSelect ? modelSelectionSelect.value : 'auto',\n    strictMode: strictModeCheckbox ? strictModeCheckbox.checked : false,\n    shortcuts: currentSettings.shortcuts // 保留现有快捷键设置\n  };\n  \n  chrome.storage.sync.set(settings, () => {\n    // 显示保存成功提示\n    alert('设置已保存');\n    });\n  });\n}\n\n// 重置设置\nfunction resetSettings(): void {\n  chrome.storage.sync.set(defaultSettings, () => {\n    loadSettings();\n    alert('设置已重置');\n  });\n}\n\n// 测试API连接\nasync function testApiConnection(): Promise<void> {\n  const apiEndpointInput = document.getElementById('apiEndpoint') as HTMLInputElement;\n  const apiKeyInput = document.getElementById('apiKey') as HTMLInputElement;\n  const apiTestResult = document.getElementById('apiTestResult');\n  const testStatusIcon = document.getElementById('testStatusIcon');\n  const testStatusText = document.getElementById('testStatusText');\n  const testDetails = document.getElementById('testDetails');\n  \n  // 检查API设置是否完整\n  if (!apiEndpointInput.value || !apiKeyInput.value) {\n    if (apiTestResult) apiTestResult.className = 'api-test-result error';\n    if (testStatusText) testStatusText.textContent = '测试失败';\n    if (testDetails) testDetails.textContent = 'API地址和密钥不能为空';\n    if (apiTestResult) apiTestResult.classList.remove('hidden');\n    return;\n  }\n  \n  // 显示测试中状态\n  if (apiTestResult) apiTestResult.className = 'api-test-result';\n  if (testStatusText) testStatusText.textContent = '测试中...';\n  if (testDetails) testDetails.textContent = '正在连接API服务器...';\n  if (apiTestResult) apiTestResult.classList.remove('hidden');\n  \n  try {\n    // 记录开始时间\n    const startTime = performance.now();\n    \n    // 构建OpenAI标准的API端点\n    const baseUrl = apiEndpointInput.value.endsWith('/') \n      ? apiEndpointInput.value.slice(0, -1) \n      : apiEndpointInput.value;\n    \n    // 使用OpenAI标准的chat/completions端点\n    const openaiEndpoint = `${baseUrl}/v1/chat/completions`;\n    \n    console.log('[设置页面] 使用OpenAI标准端点:', openaiEndpoint);\n    \n    // 首先进行网络连接性测试\n    console.log('[设置页面] 开始网络连接性测试...');\n    \n    try {\n      // 测试1：检查端点是否可访问（HEAD请求）\n      const headResponse = await fetch(openaiEndpoint, {\n        method: 'HEAD',\n        mode: 'cors',\n        cache: 'no-cache'\n      });\n      console.log('[设置页面] HEAD请求结果:', headResponse.status, headResponse.statusText);\n    } catch (headError) {\n      console.warn('[设置页面] HEAD请求失败，可能是CORS限制:', headError);\n    }\n    \n    // 准备OpenAI标准的测试数据格式 - 按优先级排序\n    const openaiTestFormats = [\n      // 格式1：GPT-4.1 (最高优先级)\n      {\n        model: \"gpt-4.1\",\n        messages: [\n          {\n            role: \"user\",\n            content: \"这是一个API连接测试。\"\n          }\n        ],\n        max_tokens: 50,\n        temperature: 0.7\n      },\n      // 格式2：GPT-4o (第二优先级)\n      {\n        model: \"gpt-4o\",\n        messages: [\n          {\n            role: \"user\",\n            content: \"这是一个API连接测试。\"\n          }\n        ],\n        max_tokens: 50,\n        temperature: 0.7\n      },\n      // 格式3：Claude-3.7-sonnet (第三优先级)\n      {\n        model: \"claude-3-7-sonnet-20250219\",\n        messages: [\n          {\n            role: \"user\",\n            content: \"这是一个API连接测试。\"\n          }\n        ],\n        max_tokens: 50,\n        temperature: 0.7\n      },\n      // 格式4：GPT-4o-mini (第四优先级)\n      {\n        model: \"gpt-4o-mini\",\n        messages: [\n          {\n            role: \"user\",\n            content: \"这是一个API连接测试。\"\n          }\n        ],\n        max_tokens: 50,\n        temperature: 0.7\n      },\n      // 格式5：GPT-5-mini (第五优先级)\n      {\n        model: \"gpt-5-mini\",\n        messages: [\n          {\n            role: \"user\",\n            content: \"这是一个API连接测试。\"\n          }\n        ],\n        max_tokens: 50,\n        temperature: 0.7\n      }\n    ];\n    \n    console.log(`[设置页面] 将尝试 ${openaiTestFormats.length} 种OpenAI标准请求格式`);\n    \n    // 创建 AbortController 用于超时控制\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 20000); // 20秒超时\n    \n    // 准备OpenAI标准的请求头\n    const headers = {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${apiKeyInput.value}`,\n      'X-Request-ID': `settings-test-${Date.now()}`,\n      'X-Client-Version': '1.0.0',\n      'Accept': 'application/json',\n      'User-Agent': 'LongPort-AI-Extension/1.0.0'\n    };\n    \n    let successfulFormat = null;\n    let responseData = null;\n    let lastError = null;\n    \n    // 尝试多种OpenAI标准请求格式\n    for (let i = 0; i < openaiTestFormats.length; i++) {\n      const currentFormat = openaiTestFormats[i];\n      console.log(`[设置页面] 尝试OpenAI格式 ${i + 1}:`, currentFormat);\n      \n      try {\n        // 发送OpenAI标准测试请求\n        const response = await fetch(openaiEndpoint, {\n          method: 'POST',\n          headers,\n          body: JSON.stringify(currentFormat),\n          signal: controller.signal,\n          mode: 'cors',\n          cache: 'no-cache'\n        });\n        \n        console.log(`[设置页面] 格式 ${i + 1} 响应状态:`, response.status, response.statusText);\n        \n        // 记录响应头信息\n        const responseHeaders: Record<string, string> = {};\n        response.headers.forEach((value, key) => {\n          responseHeaders[key] = value;\n        });\n        console.log(`[设置页面] 格式 ${i + 1} 响应头:`, responseHeaders);\n        \n        // 检查响应状态\n        if (!response.ok) {\n          const errorText = await response.text().catch(() => '无法读取错误详情');\n          console.warn(`[设置页面] 格式 ${i + 1} 返回错误状态: ${response.status} ${response.statusText}`);\n          console.warn(`[设置页面] 格式 ${i + 1} 错误详情:`, errorText.substring(0, 200));\n          lastError = `HTTP ${response.status}: ${response.statusText}`;\n          continue; // 尝试下一个格式\n        }\n        \n        // 验证响应内容类型\n        const contentType = response.headers.get('content-type') || '';\n        console.log(`[设置页面] 格式 ${i + 1} 响应内容类型: ${contentType}`);\n        \n        // 尝试解析响应\n        try {\n          const responseText = await response.text();\n          console.log(`[设置页面] 格式 ${i + 1} 响应原始内容:`, responseText.substring(0, 500) + (responseText.length > 500 ? '...' : ''));\n          \n          // 检查是否是HTML响应\n          if (responseText.trim().toLowerCase().startsWith('<!doctype') || \n              responseText.trim().toLowerCase().startsWith('<html')) {\n            console.warn(`[设置页面] 格式 ${i + 1} 返回了HTML内容，跳过`);\n            lastError = 'API返回了HTML页面而非JSON数据';\n            continue; // 尝试下一个格式\n          }\n          \n          // 尝试将文本解析为JSON\n          try {\n            const data = JSON.parse(responseText);\n            console.log(`[设置页面] 格式 ${i + 1} 解析成功:`, data);\n            \n            // 检查OpenAI标准响应格式\n            const hasValidOpenAIResponse = data && (\n              data.choices && Array.isArray(data.choices) && data.choices.length > 0 ||\n              data.usage ||\n              data.model ||\n              data.id ||\n              data.object === 'chat.completion'\n            );\n            \n            if (hasValidOpenAIResponse) {\n              successfulFormat = i + 1;\n              responseData = data;\n              console.log(`[设置页面] 格式 ${i + 1} 成功获取有效OpenAI响应，停止尝试`);\n              break; // 找到有效格式，停止尝试\n            } else {\n              console.warn(`[设置页面] 格式 ${i + 1} 响应不符合OpenAI标准格式`);\n              lastError = '响应不符合OpenAI标准格式';\n              continue; // 尝试下一个格式\n            }\n          } catch (jsonError) {\n            console.error(`[设置页面] 格式 ${i + 1} 解析JSON失败:`, jsonError);\n            lastError = `JSON解析失败: ${jsonError instanceof Error ? jsonError.message : '未知错误'}`;\n            continue; // 尝试下一个格式\n          }\n        } catch (parseError) {\n          console.error(`[设置页面] 格式 ${i + 1} 解析响应失败:`, parseError);\n          lastError = `响应解析失败: ${parseError instanceof Error ? parseError.message : '未知错误'}`;\n          continue; // 尝试下一个格式\n        }\n      } catch (fetchError) {\n        console.error(`[设置页面] 格式 ${i + 1} 请求失败:`, fetchError);\n        lastError = `网络请求失败: ${fetchError instanceof Error ? fetchError.message : '未知错误'}`;\n        \n        // 如果是网络错误，提供更具体的诊断\n        if (fetchError instanceof TypeError && fetchError.message.includes('fetch')) {\n          lastError = '网络连接失败，请检查API端点是否可访问';\n        } else if (fetchError instanceof DOMException && fetchError.name === 'AbortError') {\n          lastError = '请求超时，请检查网络连接或API服务器状态';\n        }\n        \n        continue; // 尝试下一个格式\n      }\n    }\n    \n    // 清除超时\n    clearTimeout(timeoutId);\n    \n    // 计算响应时间\n    const responseTime = Math.round(performance.now() - startTime);\n    \n    // 检查是否找到有效的响应格式\n    if (successfulFormat && responseData) {\n      // 测试成功\n      if (apiTestResult) apiTestResult.className = 'api-test-result success';\n      if (testStatusText) testStatusText.textContent = '连接成功';\n      \n      const modelInfo = successfulFormat === 1 \n        ? `使用OpenAI格式 GPT-4.1` \n        : `使用OpenAI格式 GPT-4o`;\n      \n      if (testDetails) testDetails.textContent = `响应时间: ${responseTime}ms，${modelInfo}`;\n      \n      console.log(`[设置页面] OpenAI API连接测试成功，${modelInfo}，响应数据:`, responseData);\n    } else {\n      // 所有格式都失败\n      if (apiTestResult) apiTestResult.className = 'api-test-result error';\n      if (testStatusText) testStatusText.textContent = '连接失败';\n      \n      // 提供更详细的错误信息\n      let errorMessage = '所有OpenAI请求格式都失败了，请检查API配置和网络连接';\n      if (lastError) {\n        errorMessage += `\\n\\n最后错误: ${lastError}`;\n      }\n      errorMessage += `\\n\\n建议检查:\\n1. API端点是否正确 (应该是 https://lboneapi.longbridge-inc.com)\\n2. API密钥是否有效\\n3. 网络连接是否正常\\n4. API服务是否运行`;\n      \n      if (testDetails) testDetails.textContent = errorMessage;\n      \n      console.error('[设置页面] 所有OpenAI请求格式都失败了，最后错误:', lastError);\n    }\n  } catch (error) {\n    // 网络错误或其他异常\n    if (apiTestResult) apiTestResult.className = 'api-test-result error';\n    if (testStatusText) testStatusText.textContent = '连接失败';\n    \n    let errorMessage = error instanceof Error ? \n      `错误: ${error.message}` : \n      '发生未知错误';\n    \n    // 提供更具体的错误诊断\n    if (error instanceof TypeError && error.message.includes('fetch')) {\n      errorMessage = '网络连接失败，请检查API端点是否可访问';\n    } else if (error instanceof DOMException && error.name === 'AbortError') {\n      errorMessage = '请求超时，请检查网络连接或API服务器状态';\n    }\n    \n    if (testDetails) testDetails.textContent = errorMessage;\n    \n    console.error('[设置页面] OpenAI API连接测试出错:', error);\n  }\n}\n\n// 切换密码显示/隐藏\nfunction togglePasswordVisibility(): void {\n  const apiKeyInput = document.getElementById('apiKey') as HTMLInputElement;\n  const toggleButton = document.getElementById('togglePassword');\n  \n  if (apiKeyInput && toggleButton) {\n    if (apiKeyInput.type === 'password') {\n      apiKeyInput.type = 'text';\n      toggleButton.setAttribute('aria-label', '隐藏密码');\n      toggleButton.classList.add('show');\n    } else {\n      apiKeyInput.type = 'password';\n      toggleButton.setAttribute('aria-label', '显示密码');\n      toggleButton.classList.remove('show');\n    }\n  }\n}\n\n// 打开文案优化测试页面\nfunction openTestPage(): void {\n  chrome.tabs.create({ url: chrome.runtime.getURL('test/test.html') });\n}\n\n  // 页面加载完成后初始化\ndocument.addEventListener('DOMContentLoaded', () => {\n  // 加载设置\n  loadSettings();\n  \n  // 添加保存按钮事件监听\n  const saveBtn = document.getElementById('saveBtn');\n  if (saveBtn) {\n    saveBtn.addEventListener('click', saveSettings);\n  }\n  \n  // 添加重置按钮事件监听\n  const resetBtn = document.getElementById('resetBtn');\n  if (resetBtn) {\n    resetBtn.addEventListener('click', resetSettings);\n  }\n  \n  // 添加测试API按钮事件监听\n  const testApiBtn = document.getElementById('testApiBtn');\n  if (testApiBtn) {\n    testApiBtn.addEventListener('click', testApiConnection);\n  }\n  \n  // 添加切换密码显示/隐藏按钮事件监听\n  const togglePasswordBtn = document.getElementById('togglePassword');\n  if (togglePasswordBtn) {\n    togglePasswordBtn.addEventListener('click', togglePasswordVisibility);\n  }\n  \n  // 设置快捷键录入\n  setupShortcutRecorder('optimize');\n  setupShortcutRecorder('replace');\n  \n  // 添加文案优化测试页面按钮事件监听\n  const testPageBtn = document.getElementById('testPageBtn');\n  if (testPageBtn) {\n    testPageBtn.addEventListener('click', openTestPage);\n  }\n});\n\n// 导出一个空对象，确保这是一个有效的模块\nexport {};\n"],"names":[],"sourceRoot":""}