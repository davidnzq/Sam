(async () => {
    const { enabled, theme } = await chrome.storage.sync.get(['enabled', 'theme']);
    if (!enabled)
        return;
    document.documentElement.dataset.myStarterTheme = theme;
})();
// é‡‘èæœ¯è¯­è¯å…¸ï¼ˆå¯æ‰©å±•ï¼‰
const FIN_TERMS = {
    "å¸‚ç›ˆç‡": {
        explain: "å¸‚ç›ˆç‡æ˜¯å…¬å¸å¸‚å€¼ä¸å…¶å¹´åº¦å‡€åˆ©æ¶¦çš„æ¯”å€¼ï¼Œåæ˜ æŠ•èµ„å›æœ¬å‘¨æœŸã€‚",
        analogy: "å°±åƒä½ æŠ•èµ„ä¸€ä¸ªå°åº—ï¼Œå¸‚ç›ˆç‡è¶Šä½ï¼Œå›æœ¬è¶Šå¿«ã€‚"
    },
    "å‡€èµ„äº§æ”¶ç›Šç‡": {
        explain: "å‡€èµ„äº§æ”¶ç›Šç‡è¡¡é‡å…¬å¸ç”¨è‡ªæœ‰èµ„é‡‘èµšå–åˆ©æ¶¦çš„èƒ½åŠ›ã€‚",
        analogy: "åƒä½ ç”¨è‡ªå·±çš„é’±åšç”Ÿæ„ï¼Œèµšå¾—è¶Šå¤šï¼Œèƒ½åŠ›è¶Šå¼ºã€‚"
    },
    "å¸‚å‡€ç‡": {
        explain: "å¸‚å‡€ç‡é€šå¸¸æŒ‡è‚¡ä»·ä¸æ¯è‚¡å‡€èµ„äº§çš„æ¯”å€¼ï¼Œåæ˜ å¸‚åœºå¯¹å…¬å¸è´¦é¢èµ„äº§çš„æº¢ä»·æˆ–æŠ˜ä»·ç¨‹åº¦ã€‚",
        analogy: "åƒä¹°ä¸€å¥—äºŒæ‰‹æˆ¿ï¼Œç”¨æˆäº¤ä»·å¯¹æ¯”æˆ¿äº§è¯ä¸Šçš„'è´¦é¢ä»·å€¼'ï¼Œæº¢ä»·è¶Šé«˜ï¼Œå¤§å®¶å¯¹å®ƒæœªæ¥è¶Šçœ‹å¥½ã€‚"
    },
    "é‡æ¯”": {
        explain: "é‡æ¯”æ˜¯å½“å‰æˆäº¤é‡ä¸ä¸€æ®µæ—¶é—´ï¼ˆå¦‚è¿‡å»5ä¸ªäº¤æ˜“æ—¥ï¼‰å¹³å‡æ¯åˆ†é’Ÿæˆäº¤é‡ä¹‹æ¯”ï¼Œç”¨äºè¡¡é‡å½“æ—¥ç›¸å¯¹æˆäº¤æ´»è·ƒåº¦ã€‚",
        analogy: "å¥½æ¯”å•†åœºçš„äººæµé‡ï¼Œä»Šå¤©åŒä¸€æ—¶æ®µæ¯”å¹³æ—¶æ›´æ‹¥æŒ¤ï¼Œè¯´æ˜æ›´çƒ­é—¹ã€æ›´å—å…³æ³¨ã€‚"
    },
    "æ¢æ‰‹ç‡": {
        explain: "æ¢æ‰‹ç‡æ˜¯åœ¨ä¸€å®šæ—¶æœŸå†…è‚¡ç¥¨æ¢æ‰‹çš„é¢‘ç‡ï¼Œå¸¸ç”¨æˆäº¤è‚¡æ•°ä¸æµé€šè‚¡æœ¬ä¹‹æ¯”è¡¡é‡ï¼Œæ˜¾ç¤ºç­¹ç æ›´è¿­å’Œæ´»è·ƒåº¦ã€‚",
        analogy: "åƒå›¾ä¹¦é¦†ä¸€æœ¬çƒ­é—¨ä¹¦è¢«å€Ÿæ¥è¿˜å»çš„é¢‘ç‡ï¼Œå€Ÿå¾—è¶Šå¤šï¼Œè¶Šè¯´æ˜å¤§å®¶åœ¨å…³æ³¨å’Œè®¨è®ºã€‚"
    },
    "æŒ¯å¹…": {
        explain: "æŒ¯å¹…åˆ»ç”»ä¸€å®šå‘¨æœŸå†…ä»·æ ¼æ³¢åŠ¨çš„å¹…åº¦ï¼ˆå¦‚å½“æ—¥æœ€é«˜ä»·ä¸æœ€ä½ä»·çš„å·®é¢ç›¸å¯¹æ˜¨æ”¶ï¼‰ï¼Œä½“ç°å¸‚åœºæ³¢åŠ¨å¼ºå¼±ã€‚",
        analogy: "å°±åƒä¸€å¤©é‡Œæœ€é«˜æ¸©å’Œæœ€ä½æ¸©çš„æ¸©å·®ï¼Œæ¸©å·®è¶Šå¤§ï¼Œä½“æ„Ÿèµ·ä¼è¶Šæ˜æ˜¾ã€‚"
    },
};
// ç”¨æˆ·è‡ªå®šä¹‰è¯æ¡å­˜å‚¨
let customTerms = {};
// å·²æŒæ¡çš„è¯æ¡å­˜å‚¨
let masteredTerms = new Set();
let tooltipTimeoutId = null;
// åŠ è½½è¯æ¡æ•°æ®
async function loadTermsData() {
    try {
        const { masteredTerms: stored, customTerms: storedCustom } = await chrome.storage.sync.get(['masteredTerms', 'customTerms']);
        masteredTerms = new Set(stored || []);
        customTerms = storedCustom || {};
    }
    catch (error) {
        console.error('Failed to load terms data:', error);
        masteredTerms = new Set();
        customTerms = {};
    }
}
// ä¿å­˜è¯æ¡æ•°æ®
async function saveTermsData() {
    try {
        await chrome.storage.sync.set({
            masteredTerms: Array.from(masteredTerms),
            customTerms: customTerms
        });
    }
    catch (error) {
        console.error('Failed to save terms data:', error);
    }
}
// æ ‡è®°è¯æ¡ä¸ºå·²æŒæ¡
async function markTermAsMastered(term) {
    masteredTerms.add(term);
    await saveTermsData();
    // ç§»é™¤é¡µé¢ä¸Šçš„é«˜äº®
    const highlights = document.querySelectorAll(`[data-yiyuan-term="${term}"]`);
    highlights.forEach(highlight => {
        const parent = highlight.parentNode;
        if (parent) {
            parent.replaceChild(document.createTextNode(term), highlight);
            parent.normalize(); // åˆå¹¶ç›¸é‚»çš„æ–‡æœ¬èŠ‚ç‚¹
        }
    });
    // éšè—å¼¹çª—
    hideTooltip();
    // é€šçŸ¥background scriptæ›´æ–°ä¾§è¾¹æ 
    chrome.runtime.sendMessage({ type: 'TERM_MASTERED', term });
}
// å–æ¶ˆè¯æ¡çš„å·²æŒæ¡çŠ¶æ€
async function unmarkTermAsMastered(term) {
    masteredTerms.delete(term);
    await saveTermsData();
    // é‡æ–°æ‰«æé¡µé¢ä»¥é«˜äº®è¯¥è¯æ¡
    triggerScanDebounced(0);
    // é€šçŸ¥background scriptæ›´æ–°ä¾§è¾¹æ 
    chrome.runtime.sendMessage({ type: 'TERM_UNMASTERED', term });
}
// æ·»åŠ è‡ªå®šä¹‰è¯æ¡
async function addCustomTerm(term, explain, analogy) {
    customTerms[term] = {
        explain,
        analogy,
        createdAt: Date.now()
    };
    await saveTermsData();
    // é‡æ–°æ‰«æé¡µé¢ä»¥é«˜äº®æ–°è¯æ¡
    triggerScanDebounced(0);
}
// è°ƒç”¨ ChatGPT API ç”Ÿæˆè§£è¯»å’Œç±»æ¯”ï¼ˆé€šè¿‡åå°è°ƒç”¨ï¼Œè§„é¿å†…å®¹è„šæœ¬çš„CORSé—®é¢˜ï¼‰
async function generateTermExplanation(term) {
    try {
        // æ£€æŸ¥æ‰©å±•æ˜¯å¦å¯ç”¨
        if (!chrome.runtime || !chrome.runtime.id) {
            console.warn('æ‰©å±•ä¸Šä¸‹æ–‡ä¸å¯ç”¨ï¼Œä½¿ç”¨æœ¬åœ°å¤‡ç”¨è§£è¯»');
            return generateFallbackExplanation(term);
        }
        const resp = await new Promise((resolve, reject) => {
            try {
                chrome.runtime.sendMessage({ type: 'AI_GENERATE_EXPLANATION', term }, (res) => {
                    if (chrome.runtime.lastError) {
                        // å¤„ç†æ‰©å±•ä¸Šä¸‹æ–‡å¤±æ•ˆç­‰é”™è¯¯
                        const errorMessage = chrome.runtime.lastError.message || 'Unknown error';
                        if (errorMessage.includes('Extension context invalidated')) {
                            reject(new Error('æ‰©å±•å·²é‡æ–°åŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•'));
                        }
                        else {
                            reject(new Error(errorMessage));
                        }
                        return;
                    }
                    resolve(res || { ok: false, error: 'empty response' });
                });
            }
            catch (error) {
                reject(error);
            }
        });
        if (resp.ok && resp.data) {
            return resp.data;
        }
        console.warn('åå°AIç”Ÿæˆå¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°å¤‡ç”¨ï¼š', resp.error);
        return generateFallbackExplanation(term);
    }
    catch (error) {
        console.error('è°ƒç”¨åå°AIå¤±è´¥ï¼š', error);
        // æ ¹æ®é”™è¯¯ç±»å‹æä¾›æ›´å‹å¥½çš„æç¤º
        if (error.message.includes('Extension context invalidated') ||
            error.message.includes('æ‰©å±•å·²é‡æ–°åŠ è½½')) {
            console.warn('æ‰©å±•ä¸Šä¸‹æ–‡å¤±æ•ˆï¼Œå»ºè®®åˆ·æ–°é¡µé¢');
        }
        return generateFallbackExplanation(term);
    }
}
// å¤‡ç”¨æ–¹æ¡ˆï¼šç”ŸæˆåŸºç¡€è§£è¯»å’Œç±»æ¯”
function generateFallbackExplanation(term) {
    // æ£€æµ‹æœ¯è¯­è¯­è¨€
    const isEnglish = /^[a-zA-Z\s]+$/.test(term.trim());
    if (isEnglish) {
        // è‹±æ–‡æœ¯è¯­çš„åŒè¯­è§£è¯»
        const englishTemplates = [
            {
                explain: `${term} is an important concept in the financial field, typically used to measure and analyze related financial indicators. (${term}æ˜¯é‡‘èé¢†åŸŸçš„ä¸€ä¸ªé‡è¦æ¦‚å¿µï¼Œé€šå¸¸ç”¨äºè¡¡é‡å’Œåˆ†æç›¸å…³çš„é‡‘èæŒ‡æ ‡ã€‚)`,
                analogy: `Just as a thermometer measures temperature, ${term} helps us understand the state of financial markets. (å°±åƒæ¸©åº¦è®¡æµ‹é‡æ¸©åº¦ä¸€æ ·ï¼Œ${term}å¸®åŠ©æˆ‘ä»¬äº†è§£é‡‘èå¸‚åœºçš„çŠ¶æ€ã€‚)`
            },
            {
                explain: `${term} reflects certain patterns or characteristics in financial markets and serves as an important reference for investment decisions. (${term}åæ˜ äº†é‡‘èå¸‚åœºä¸­çš„æŸç§è§„å¾‹æˆ–ç‰¹å¾ï¼Œæ˜¯æŠ•èµ„å†³ç­–çš„é‡è¦å‚è€ƒã€‚)`,
                analogy: `Like weather forecasts help us plan our trips, ${term} helps us make investment decisions. (å°±åƒå¤©æ°”é¢„æŠ¥å¸®åŠ©æˆ‘ä»¬å®‰æ’å‡ºè¡Œä¸€æ ·ï¼Œ${term}å¸®åŠ©æˆ‘ä»¬åšå‡ºæŠ•èµ„å†³ç­–ã€‚)`
            },
            {
                explain: `${term} is a financial analysis tool that helps us better understand market dynamics and trends. (${term}æ˜¯é‡‘èåˆ†æå·¥å…·ï¼Œèƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬æ›´å¥½åœ°ç†è§£å¸‚åœºåŠ¨æ€å’Œè¶‹åŠ¿ã€‚)`,
                analogy: `Just as a compass guides direction, ${term} guides us to find the right investment direction in financial markets. (å°±åƒæŒ‡å—é’ˆæŒ‡å¼•æ–¹å‘ä¸€æ ·ï¼Œ${term}æŒ‡å¼•æˆ‘ä»¬åœ¨é‡‘èå¸‚åœºä¸­æ‰¾åˆ°æ­£ç¡®çš„æŠ•èµ„æ–¹å‘ã€‚)`
            }
        ];
        const randomIndex = Math.floor(Math.random() * englishTemplates.length);
        return englishTemplates[randomIndex];
    }
    else {
        // ä¸­æ–‡æœ¯è¯­çš„ä¸­æ–‡è§£è¯»
        const chineseTemplates = [
            {
                explain: `${term}æ˜¯é‡‘èé¢†åŸŸçš„ä¸€ä¸ªé‡è¦æ¦‚å¿µï¼Œé€šå¸¸ç”¨äºè¡¡é‡å’Œåˆ†æç›¸å…³çš„é‡‘èæŒ‡æ ‡ã€‚`,
                analogy: `å°±åƒæµ‹é‡æ¸©åº¦éœ€è¦æ¸©åº¦è®¡ä¸€æ ·ï¼Œ${term}å¸®åŠ©æˆ‘ä»¬äº†è§£é‡‘èå¸‚åœºçš„çŠ¶æ€ã€‚`
            },
            {
                explain: `${term}åæ˜ äº†é‡‘èå¸‚åœºä¸­çš„æŸç§è§„å¾‹æˆ–ç‰¹å¾ï¼Œæ˜¯æŠ•èµ„å†³ç­–çš„é‡è¦å‚è€ƒã€‚`,
                analogy: `å°±åƒå¤©æ°”é¢„æŠ¥å¸®åŠ©æˆ‘ä»¬å®‰æ’å‡ºè¡Œä¸€æ ·ï¼Œ${term}å¸®åŠ©æˆ‘ä»¬åšå‡ºæŠ•èµ„å†³ç­–ã€‚`
            },
            {
                explain: `${term}æ˜¯é‡‘èåˆ†æå·¥å…·ï¼Œèƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬æ›´å¥½åœ°ç†è§£å¸‚åœºåŠ¨æ€å’Œè¶‹åŠ¿ã€‚`,
                analogy: `å°±åƒæŒ‡å—é’ˆæŒ‡å¼•æ–¹å‘ä¸€æ ·ï¼Œ${term}æŒ‡å¼•æˆ‘ä»¬åœ¨é‡‘èå¸‚åœºä¸­æ‰¾åˆ°æ­£ç¡®çš„æŠ•èµ„æ–¹å‘ã€‚`
            }
        ];
        const randomIndex = Math.floor(Math.random() * chineseTemplates.length);
        return chineseTemplates[randomIndex];
    }
}
// è·å–æ‰€æœ‰è¯æ¡ï¼ˆå†…ç½® + è‡ªå®šä¹‰ï¼‰
function getAllTerms() {
    return { ...FIN_TERMS, ...customTerms };
}
// æ£€æŸ¥æ–‡æœ¬æ˜¯å¦ä¸ºæœ‰æ•ˆæ–‡æœ¬ä¸”ä¸è¶…è¿‡15ä¸ªå­—ç¬¦
function isValidText(text) {
    const trimmedText = text.trim();
    const totalLength = trimmedText.length;
    // æ£€æŸ¥é•¿åº¦é™åˆ¶
    if (totalLength > 15) {
        return false;
    }
    // æ£€æŸ¥æ˜¯å¦åŒ…å«æœ‰æ•ˆå­—ç¬¦ï¼ˆä¸­æ–‡ã€è‹±æ–‡ã€æ•°å­—ã€ç©ºæ ¼ï¼‰
    const validCharRegex = /^[\u4e00-\u9fa5a-zA-Z0-9\s]+$/;
    if (!validCharRegex.test(trimmedText)) {
        return false;
    }
    // æ£€æŸ¥æ˜¯å¦è‡³å°‘åŒ…å«ä¸€ä¸ªæœ‰æ•ˆå­—ç¬¦ï¼ˆä¸­æ–‡æˆ–è‹±æ–‡ï¼‰
    const hasChinese = /[\u4e00-\u9fa5]/.test(trimmedText);
    const hasEnglish = /[a-zA-Z]/.test(trimmedText);
    return hasChinese || hasEnglish;
}
// æ£€æŸ¥æ–‡æœ¬æ˜¯å¦ä¸ºä¸­æ–‡ä¸”ä¸è¶…è¿‡15ä¸ªå­—ç¬¦ï¼ˆä¿æŒå‘åå…¼å®¹ï¼‰
function isValidChineseText(text) {
    // å…è®¸ä¸­æ–‡ã€æ•°å­—ã€è‹±æ–‡å’Œç©ºæ ¼ï¼Œä½†ä¸»è¦å­—ç¬¦å¿…é¡»æ˜¯ä¸­æ–‡
    const chineseRegex = /^[\u4e00-\u9fa5\s\w]+$/;
    const chineseCount = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
    const totalLength = text.trim().length;
    // ä¸»è¦å­—ç¬¦å¿…é¡»æ˜¯ä¸­æ–‡ï¼Œä¸”æ€»é•¿åº¦ä¸è¶…è¿‡15ä¸ªå­—ç¬¦
    return chineseCount > 0 && chineseCount >= totalLength * 0.6 && totalLength <= 15;
}
// åˆ›å»ºå³é”®èœå•
function createContextMenu() {
    // ç§»é™¤å·²å­˜åœ¨çš„å³é”®èœå•
    const existingMenu = document.getElementById('fin-terms-context-menu');
    if (existingMenu) {
        existingMenu.remove();
    }
    const menu = document.createElement('div');
    menu.id = 'fin-terms-context-menu';
    menu.className = 'fin-terms-context-menu';
    menu.style.display = 'none';
    document.body.appendChild(menu);
    return menu;
}
// æ˜¾ç¤ºå³é”®èœå•
function showContextMenu(x, y, selectedText) {
    const menu = createContextMenu();
    menu.innerHTML = `
    <div class="context-menu-item" data-action="explain" data-text="${selectedText}">
      <span class="context-menu-icon">ğŸ“–</span>
      è§£è¯»
    </div>
  `;
    // æ·»åŠ äº‹ä»¶ç›‘å¬
    const explainItem = menu.querySelector('[data-action="explain"]');
    if (explainItem) {
        explainItem.addEventListener('click', () => {
            showCustomTermTooltip(selectedText, { x, y });
            hideContextMenu();
        });
    }
    // å®šä½èœå•
    menu.style.left = `${x}px`;
    menu.style.top = `${y}px`;
    menu.style.display = 'block';
}
// éšè—å³é”®èœå•
function hideContextMenu() {
    const menu = document.getElementById('fin-terms-context-menu');
    if (menu) {
        menu.style.display = 'none';
    }
}
// æ˜¾ç¤ºè‡ªå®šä¹‰è¯æ¡å¼¹çª—
function showCustomTermTooltip(term, position) {
    const allTerms = getAllTerms();
    const existingTerm = allTerms[term];
    if (existingTerm) {
        // å¦‚æœè¯æ¡å·²å­˜åœ¨ï¼Œæ˜¾ç¤ºè§£è¯»å¼¹çª—
        const rect = {
            left: position.x,
            top: position.y,
            right: position.x + 100,
            bottom: position.y + 20
        };
        // æ£€æŸ¥æ˜¯å¦ä¸ºå·²æŒæ¡çš„è¯æ¡
        if (masteredTerms.has(term)) {
            // å¦‚æœæ˜¯å·²æŒæ¡çš„è¯æ¡ï¼Œæ˜¾ç¤ºè§£è¯»å¼¹çª—å¹¶å–æ¶ˆæŒæ¡çŠ¶æ€
            showTooltip(term, rect);
            // å»¶è¿Ÿå–æ¶ˆæŒæ¡çŠ¶æ€ï¼Œé¿å…å¼¹çª—ç«‹å³æ¶ˆå¤±
            setTimeout(() => {
                unmarkTermAsMastered(term);
            }, 100);
        }
        else {
            // æ™®é€šè¯æ¡ç›´æ¥æ˜¾ç¤ºè§£è¯»å¼¹çª—
            showTooltip(term, rect);
        }
    }
    else {
        // å¦‚æœè¯æ¡ä¸å­˜åœ¨ï¼Œç›´æ¥æ˜¾ç¤ºAIç”Ÿæˆçš„è§£è¯»å¼¹çª—
        showNewTermTooltip(term, position);
    }
}
// æ˜¾ç¤ºæ·»åŠ è¯æ¡å¼¹çª—
function showAddTermTooltip(term, position) {
    const host = getTooltip();
    if (!tooltipContentEl)
        return;
    tooltipContentEl.innerHTML = `
    <h4 class="title">æ·»åŠ æ–°è¯æ¡ï¼š${term}</h4>
    <div class="section">
      <div class="label">è§£è¯»</div>
      <textarea class="explain-input" placeholder="è¯·è¾“å…¥è¯æ¡è§£è¯»..." rows="3"></textarea>
    </div>
    <div class="section">
      <div class="label">ç±»æ¯”</div>
      <textarea class="analogy-input" placeholder="è¯·è¾“å…¥ç±»æ¯”è¯´æ˜..." rows="2"></textarea>
    </div>
    <div class="button-group">
      <button class="auto-generate-button" data-term="${term}">ğŸ¤– AIè‡ªåŠ¨ç”Ÿæˆ</button>
    </div>
    <div class="button-group">
      <button class="add-button" data-term="${term}">æ·»åŠ è¯æ¡</button>
      <button class="cancel-button">å–æ¶ˆ</button>
    </div>
  `;
    // æ·»åŠ äº‹ä»¶ç›‘å¬
    const addButton = tooltipContentEl.querySelector('.add-button');
    const cancelButton = tooltipContentEl.querySelector('.cancel-button');
    const autoGenerateButton = tooltipContentEl.querySelector('.auto-generate-button');
    const explainInput = tooltipContentEl.querySelector('.explain-input');
    const analogyInput = tooltipContentEl.querySelector('.analogy-input');
    // AIè‡ªåŠ¨ç”ŸæˆæŒ‰é’®äº‹ä»¶
    if (autoGenerateButton) {
        autoGenerateButton.addEventListener('click', async () => {
            autoGenerateButton.textContent = 'ğŸ”„ ç”Ÿæˆä¸­...';
            autoGenerateButton.disabled = true;
            try {
                const result = await generateTermExplanation(term);
                if (result) {
                    explainInput.value = result.explain;
                    analogyInput.value = result.analogy;
                    showSuccessMessage('AIè§£è¯»ç”ŸæˆæˆåŠŸï¼');
                }
                else {
                    showErrorMessage('AIç”Ÿæˆå¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¡«å†™');
                }
            }
            catch (error) {
                console.error('AIç”Ÿæˆå¤±è´¥:', error);
                showErrorMessage('AIç”Ÿæˆå¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¡«å†™');
            }
            finally {
                autoGenerateButton.textContent = 'ğŸ¤– AIè‡ªåŠ¨ç”Ÿæˆ';
                autoGenerateButton.disabled = false;
            }
        });
    }
    if (addButton) {
        addButton.addEventListener('click', async () => {
            const explain = explainInput.value.trim();
            const analogy = analogyInput.value.trim();
            if (explain && analogy) {
                await addCustomTerm(term, explain, analogy);
                hideTooltip();
                // æ˜¾ç¤ºæˆåŠŸæç¤º
                showSuccessMessage('è¯æ¡æ·»åŠ æˆåŠŸï¼');
            }
            else {
                showErrorMessage('è¯·å¡«å†™å®Œæ•´çš„è§£è¯»å’Œç±»æ¯”ä¿¡æ¯');
            }
        });
    }
    if (cancelButton) {
        cancelButton.addEventListener('click', () => {
            hideTooltip();
        });
    }
    host.style.display = 'block';
    host.style.left = `${position.x}px`;
    host.style.top = `${position.y + 20}px`;
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    if (tooltipTimeoutId) {
        clearTimeout(tooltipTimeoutId);
        tooltipTimeoutId = null;
    }
}
// æ˜¾ç¤ºæ–°å¢è¯æ¡çš„è§£è¯»å¼¹çª—ï¼ˆAIç”Ÿæˆå†…å®¹ï¼‰
async function showNewTermTooltip(term, position) {
    const host = getTooltip();
    if (!tooltipContentEl)
        return;
    // å…ˆæ˜¾ç¤ºåŠ è½½çŠ¶æ€
    tooltipContentEl.innerHTML = `
    <h4 class="title">æ–°è¯æ¡è§£è¯»ï¼š${term}</h4>
    <div class="section">
      <div class="label">è§£è¯»</div>
      <div class="loading-text">ğŸ”„ AIæ­£åœ¨ç”Ÿæˆè§£è¯»å†…å®¹...</div>
    </div>
    <div class="section">
      <div class="label">ç±»æ¯”</div>
      <div class="loading-text">ğŸ”„ AIæ­£åœ¨ç”Ÿæˆç±»æ¯”å†…å®¹...</div>
    </div>
    <div class="button-group">
      <button class="add-button" data-term="${term}">æ·»åŠ è¯æ¡</button>
      <button class="cancel-button">å–æ¶ˆ</button>
    </div>
  `;
    host.style.display = 'block';
    host.style.left = `${position.x}px`;
    host.style.top = `${position.y + 20}px`;
    // è‡ªåŠ¨ç”ŸæˆAIå†…å®¹
    try {
        const result = await generateTermExplanation(term);
        if (result) {
            tooltipContentEl.innerHTML = `
        <h4 class="title">æ–°è¯æ¡è§£è¯»ï¼š${term}</h4>
        <div class="section">
          <div class="label">è§£è¯»</div>
          <div class="text">${result.explain}</div>
        </div>
        <div class="section">
          <div class="label">ç±»æ¯”</div>
          <div class="text">${result.analogy}</div>
        </div>
        <div class="button-group">
          <button class="add-button" data-term="${term}">æ·»åŠ è¯æ¡</button>
          <button class="cancel-button">å–æ¶ˆ</button>
        </div>
      `;
            // é‡æ–°ç»‘å®šäº‹ä»¶
            const addButton = tooltipContentEl.querySelector('.add-button');
            const cancelButton = tooltipContentEl.querySelector('.cancel-button');
            if (addButton) {
                addButton.addEventListener('click', async () => {
                    await addCustomTerm(term, result.explain, result.analogy);
                    hideTooltip();
                    showSuccessMessage('è¯æ¡æ·»åŠ æˆåŠŸï¼');
                });
            }
            if (cancelButton) {
                cancelButton.addEventListener('click', () => {
                    hideTooltip();
                });
            }
        }
    }
    catch (error) {
        console.error('AIç”Ÿæˆå¤±è´¥:', error);
        // å¦‚æœAIç”Ÿæˆå¤±è´¥ï¼Œæ˜¾ç¤ºæ‰‹åŠ¨è¾“å…¥ç•Œé¢
        showAddTermTooltip(term, position);
    }
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    if (tooltipTimeoutId) {
        clearTimeout(tooltipTimeoutId);
        tooltipTimeoutId = null;
    }
}
// æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
function showSuccessMessage(message) {
    showMessage(message, 'success');
}
// æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
function showErrorMessage(message) {
    showMessage(message, 'error');
}
// æ˜¾ç¤ºæ¶ˆæ¯æç¤º
function showMessage(message, type) {
    const messageEl = document.createElement('div');
    messageEl.className = `fin-terms-message fin-terms-message-${type}`;
    messageEl.textContent = message;
    document.body.appendChild(messageEl);
    setTimeout(() => {
        messageEl.remove();
    }, 3000);
}
// â€”â€” æ ·å¼ â€”â€”
function ensureStyles() {
    if (document.getElementById('yiyuan-style'))
        return;
    const style = document.createElement('style');
    style.id = 'yiyuan-style';
    style.textContent = `
  .yiyuan-highlight { background: #fff3bf; border-bottom: 1px dashed #c59f00; cursor: help; }
  .yiyuan-highlight.mastered { background: #e8f5e8; border-bottom: 1px dashed #4caf50; }
  /* tooltip çš„åŸºç¡€ç±»ï¼ˆå®¿ä¸»ä¸ä½¿ç”¨æ­¤ç±»æ¸²æŸ“ï¼Œæ ·å¼ä»¥ Shadow DOM æ³¨å…¥ä¸ºä¸»ï¼›è¿™é‡Œä¿ç•™å…œåº•ï¼‰*/
  .yiyuan-tooltip { position: fixed; max-width: 360px; background: #fff; border: 1px solid #d0d0d0; box-shadow: 0 4px 14px rgba(0,0,0,0.15); padding: 12px 14px; z-index: 999999; font-size: 13px; line-height: 1.4; border-radius: 6px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
  .yiyuan-tooltip .yiyuan-highlight { background: transparent !important; border: 0 !important; cursor: default; }
  
  /* å³é”®èœå•æ ·å¼ */
  .fin-terms-context-menu {
    position: fixed;
    background: #fff;
    border: 1px solid #d0d0d0;
    border-radius: 8px;
    box-shadow: 0 4px 14px rgba(0,0,0,0.15);
    z-index: 999997;
    min-width: 120px;
    padding: 8px 0;
  }
  .context-menu-item {
    padding: 8px 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: background 0.2s;
  }
  .context-menu-item:hover {
    background: #f5f5f5;
  }
  .context-menu-icon {
    font-size: 14px;
  }
  
  /* æ¶ˆæ¯æç¤ºæ ·å¼ */
  .fin-terms-message {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 12px 20px;
    border-radius: 6px;
    color: white;
    font-weight: 500;
    z-index: 999999;
    animation: slideIn 0.3s ease;
  }
  .fin-terms-message-success {
    background: #4caf50;
  }
  .fin-terms-message-error {
    background: #f44336;
  }
  @keyframes slideIn {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  
  /* ä¾§è¾¹æ æ ·å¼ */
  .fin-terms-sidebar {
    position: fixed;
    top: 0;
    right: -500px;
    width: 500px;
    height: 100vh;
    background: #fff;
    box-shadow: -2px 0 10px rgba(0,0,0,0.1);
    z-index: 999998;
    transition: right 0.3s ease;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  }
  .fin-terms-sidebar.open {
    right: 0;
  }
  .fin-terms-sidebar-header {
    padding: 20px;
    border-bottom: 1px solid #eee;
    background: #f8f9fa;
  }
  .fin-terms-sidebar-title {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
    color: #333;
  }
  .fin-terms-sidebar-close {
    position: absolute;
    top: 20px;
    right: 20px;
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    color: #666;
  }
  .fin-terms-sidebar-content {
    padding: 20px;
    overflow-y: auto;
    height: calc(100vh - 80px);
  }
  
  /* Tab æ ·å¼ */
  .fin-terms-tabs {
    display: flex;
    border-bottom: 1px solid #ddd;
    margin-bottom: 20px;
  }
  .fin-terms-tab {
    padding: 12px 20px;
    cursor: pointer;
    border: none;
    background: none;
    font-size: 14px;
    color: #666;
    border-bottom: 2px solid transparent;
    transition: all 0.2s;
  }
  .fin-terms-tab.active {
    color: #333;
    border-bottom-color: #4caf50;
  }
  .fin-terms-tab-content {
    display: none;
  }
  .fin-terms-tab-content.active {
    display: block;
  }
  
  .mastered-term-item {
    padding: 15px;
    margin-bottom: 10px;
    background: #f8f9fa;
    border-radius: 8px;
    border-left: 4px solid #4caf50;
  }
  .mastered-term-title {
    font-weight: 600;
    color: #333;
    margin-bottom: 8px;
  }
  .mastered-term-explain {
    color: #666;
    font-size: 14px;
    line-height: 1.5;
  }
  .mastered-term-date {
    color: #999;
    font-size: 12px;
    margin-top: 8px;
  }
  .no-mastered-terms {
    text-align: center;
    color: #999;
    padding: 40px 20px;
  }
  
  .custom-term-item {
    padding: 15px;
    margin-bottom: 10px;
    background: #f0f8ff;
    border-radius: 8px;
    border-left: 4px solid #2196f3;
  }
  .custom-term-title {
    font-weight: 600;
    color: #333;
    margin-bottom: 8px;
  }
  .custom-term-explain {
    color: #666;
    font-size: 14px;
    line-height: 1.5;
  }
  .custom-term-date {
    color: #999;
    font-size: 12px;
    margin-top: 8px;
  }
  .no-custom-terms {
    text-align: center;
    color: #999;
    padding: 40px 20px;
  }
  `;
    document.head.appendChild(style);
}
// â€”â€” å·¥å…· â€”â€”
function escapeRegExp(input) {
    return input.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
// å®‰å…¨è·å–äº‹ä»¶ç›®æ ‡çš„ Elementï¼ˆæœ‰äº›ç«™ç‚¹å¯èƒ½è§¦å‘ Text/Comment èŠ‚ç‚¹ä½œä¸º targetï¼‰
function getEventElement(e) {
    // Prefer composedPath for Shadow DOM robustness
    const path = typeof e.composedPath === 'function' ? e.composedPath() : [];
    const elFromPath = path.find(n => n instanceof Element);
    if (elFromPath)
        return elFromPath;
    const t = e.target;
    if (t instanceof Element)
        return t;
    if (t && t.nodeType === Node.TEXT_NODE)
        return t.parentElement;
    return null;
}
// Shadow DOM tooltip
let tooltipHost = null;
let tooltipContentEl = null;
function getTooltip() {
    if (!tooltipHost) {
        tooltipHost = document.createElement('div');
        tooltipHost.setAttribute('data-yiyuan-skip', '1');
        tooltipHost.style.position = 'fixed';
        tooltipHost.style.zIndex = '999999';
        tooltipHost.style.display = 'none';
        document.body.appendChild(tooltipHost);
        const shadowRoot = tooltipHost.attachShadow({ mode: 'open' });
        const style = document.createElement('style');
        style.textContent = `
      :host { all: initial; }
      .tooltip { max-width: 380px; background: #fff; border: 1px solid #d0d0d0; box-shadow: 0 4px 14px rgba(0,0,0,0.15); padding: 12px 14px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif; font-size: 13px; line-height: 1.7; border-radius: 8px; color: #222; }
      .title { display: block; margin: 0 0 10px 0; font-weight: 700; font-size: 18px; line-height: 1.45; color: #111; }
      .section { margin-top: 10px; }
      .label { font-weight: 600; margin-bottom: 4px; color: #111; }
      .text { color: #333; white-space: normal; }
      .loading-text { 
        color: #666; 
        font-style: italic; 
        text-align: center; 
        padding: 20px 0;
      }
      .explain-input, .analogy-input {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 13px;
        font-family: inherit;
        resize: vertical;
        box-sizing: border-box;
      }
      .explain-input:focus, .analogy-input:focus {
        outline: none;
        border-color: #4caf50;
      }
      .button-group {
        display: flex;
        gap: 10px;
        margin-top: 15px;
      }
      .add-button, .cancel-button, .auto-generate-button {
        padding: 8px 16px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: background 0.2s;
        flex: 1;
      }
      .auto-generate-button {
        background: #2196f3;
        color: white;
        margin-bottom: 8px;
        width: 100%;
      }
      .auto-generate-button:hover { background: #1976d2; }
      .auto-generate-button:active { background: #1565c0; }
      .auto-generate-button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      .add-button {
        background: #4caf50;
        color: white;
      }
      .add-button:hover { background: #45a049; }
      .add-button:active { background: #3d8b40; }
      .cancel-button {
        background: #f5f5f5;
        color: #333;
      }
      .cancel-button:hover { background: #e8e8e8; }
      .master-button { 
        margin-top: 15px; 
        padding: 8px 16px; 
        background: #4caf50; 
        color: white; 
        border: none; 
        border-radius: 6px; 
        cursor: pointer; 
        font-size: 14px; 
        font-weight: 500;
        transition: background 0.2s;
      }
      .master-button:hover { background: #45a049; }
      .master-button:active { background: #3d8b40; }
    `;
        const wrapper = document.createElement('div');
        wrapper.className = 'tooltip';
        tooltipContentEl = document.createElement('div');
        wrapper.appendChild(tooltipContentEl);
        shadowRoot.appendChild(style);
        shadowRoot.appendChild(wrapper);
    }
    return tooltipHost;
}
function showTooltip(term, anchorRect) {
    const allTerms = getAllTerms();
    const data = allTerms[term];
    if (!data)
        return;
    const host = getTooltip();
    if (!tooltipContentEl)
        return;
    tooltipContentEl.innerHTML = `
    <h4 class="title">${term}</h4>
    <div class="section">
      <div class="label">è§£è¯»</div>
      <div class="text">${data.explain}</div>
    </div>
    <div class="section">
      <div class="label">ç±»æ¯”</div>
      <div class="text">${data.analogy}</div>
    </div>
    <button class="master-button" data-term="${term}">æŒæ¡</button>
  `;
    // æ·»åŠ æŒæ¡æŒ‰é’®äº‹ä»¶
    const masterButton = tooltipContentEl.querySelector('.master-button');
    if (masterButton) {
        masterButton.addEventListener('click', () => {
            markTermAsMastered(term);
        });
    }
    host.style.display = 'block';
    const desiredLeft = anchorRect.right + 8;
    const maxLeft = Math.max(8, Math.min(desiredLeft, window.innerWidth - host.offsetWidth - 8));
    const desiredTop = Math.max(8, Math.min(anchorRect.top, window.innerHeight - host.offsetHeight - 8));
    host.style.left = `${maxLeft}px`;
    host.style.top = `${desiredTop}px`;
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    if (tooltipTimeoutId) {
        clearTimeout(tooltipTimeoutId);
        tooltipTimeoutId = null;
    }
}
function hideTooltip() {
    if (tooltipHost) {
        // è®¾ç½®å»¶è¿Ÿéšè—ï¼Œç»™ç”¨æˆ·æ—¶é—´ç§»åŠ¨åˆ°å¼¹çª—ä¸Š
        tooltipTimeoutId = window.setTimeout(() => {
            if (tooltipHost) {
                tooltipHost.style.display = 'none';
            }
        }, 500); // ä»300msæ”¹ä¸º500ms
    }
}
function cancelHideTooltip() {
    if (tooltipTimeoutId) {
        clearTimeout(tooltipTimeoutId);
        tooltipTimeoutId = null;
    }
}
// ä¾§è¾¹æ ç®¡ç†
let sidebar = null;
function createSidebar() {
    if (sidebar)
        return sidebar;
    sidebar = document.createElement('div');
    sidebar.className = 'fin-terms-sidebar';
    sidebar.setAttribute('data-fin-skip', '1');
    sidebar.innerHTML = `
    <div class="fin-terms-sidebar-header">
      <h2 class="fin-terms-sidebar-title">è¯æ¡ç®¡ç†</h2>
      <button class="fin-terms-sidebar-close">&times;</button>
    </div>
    <div class="fin-terms-sidebar-content">
      <div class="fin-terms-tabs">
        <button class="fin-terms-tab active" data-tab="custom">æ·»åŠ è¯æ¡</button>
        <button class="fin-terms-tab" data-tab="mastered">å·²æŒæ¡è¯æ¡</button>
      </div>
      
      <div class="fin-terms-tab-content active" data-tab="custom">
        <div class="no-custom-terms">æš‚æ— è‡ªå®šä¹‰è¯æ¡</div>
      </div>
      
      <div class="fin-terms-tab-content" data-tab="mastered">
        <div class="no-mastered-terms">æš‚æ— å·²æŒæ¡çš„è¯æ¡</div>
      </div>
    </div>
  `;
    // å…³é—­æŒ‰é’®äº‹ä»¶
    const closeBtn = sidebar.querySelector('.fin-terms-sidebar-close');
    if (closeBtn) {
        closeBtn.addEventListener('click', () => {
            hideSidebar();
        });
    }
    // Tab åˆ‡æ¢äº‹ä»¶
    const tabs = sidebar.querySelectorAll('.fin-terms-tab');
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const tabName = tab.getAttribute('data-tab');
            if (tabName) {
                // æ›´æ–° tab çŠ¶æ€
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                // æ›´æ–°å†…å®¹æ˜¾ç¤º
                if (sidebar) {
                    const contents = sidebar.querySelectorAll('.fin-terms-tab-content');
                    contents.forEach(content => {
                        content.classList.remove('active');
                        if (content.getAttribute('data-tab') === tabName) {
                            content.classList.add('active');
                        }
                    });
                }
                // æ›´æ–°å¯¹åº”å†…å®¹
                if (tabName === 'custom') {
                    updateCustomTermsContent();
                }
                else if (tabName === 'mastered') {
                    updateMasteredTermsContent();
                }
            }
        });
    });
    // ç‚¹å‡»å¤–éƒ¨å…³é—­
    document.addEventListener('click', (e) => {
        const target = e.target;
        if (sidebar && !sidebar.contains(target)) {
            // å®‰å…¨åœ°æ£€æŸ¥ target æ˜¯å¦ä¸º Element ç±»å‹å¹¶æ”¯æŒ closest æ–¹æ³•
            if (target && typeof target === 'object' && 'closest' in target && typeof target.closest === 'function') {
                const element = target;
                if (!element.closest('[data-fin-term]')) {
                    hideSidebar();
                }
            }
            else {
                // å¦‚æœ target ä¸æ”¯æŒ closest æ–¹æ³•ï¼Œç›´æ¥éšè—ä¾§è¾¹æ 
                hideSidebar();
            }
        }
    });
    document.body.appendChild(sidebar);
    return sidebar;
}
function showSidebar() {
    const sidebarEl = createSidebar();
    sidebarEl.classList.add('open');
    updateCustomTermsContent();
    updateMasteredTermsContent();
}
function hideSidebar() {
    if (sidebar) {
        sidebar.classList.remove('open');
    }
}
function updateCustomTermsContent() {
    if (!sidebar)
        return;
    const content = sidebar.querySelector('.fin-terms-tab-content[data-tab="custom"]');
    if (!content) {
        console.error('Custom tab content not found');
        return;
    }
    console.log('Updating custom terms content, count:', Object.keys(customTerms).length);
    if (Object.keys(customTerms).length === 0) {
        content.innerHTML = '<div class="no-custom-terms">æš‚æ— è‡ªå®šä¹‰è¯æ¡</div>';
        return;
    }
    const termsList = Object.entries(customTerms).map(([term, data]) => {
        return `
      <div class="custom-term-item">
        <div class="custom-term-title">${term}</div>
        <div class="custom-term-explain">${data.explain}</div>
        <div class="custom-term-date">åˆ›å»ºæ—¶é—´: ${new Date(data.createdAt).toLocaleDateString('zh-CN')}</div>
      </div>
    `;
    }).join('');
    content.innerHTML = termsList;
    console.log('Custom terms content updated');
}
function updateMasteredTermsContent() {
    if (!sidebar)
        return;
    const content = sidebar.querySelector('.fin-terms-tab-content[data-tab="mastered"]');
    if (!content) {
        console.error('Mastered tab content not found');
        return;
    }
    console.log('Updating mastered terms content, count:', masteredTerms.size);
    if (masteredTerms.size === 0) {
        content.innerHTML = '<div class="no-mastered-terms">æš‚æ— å·²æŒæ¡çš„è¯æ¡</div>';
        return;
    }
    const allTerms = getAllTerms();
    const termsList = Array.from(masteredTerms).map(term => {
        const data = allTerms[term];
        if (!data)
            return '';
        return `
      <div class="mastered-term-item">
        <div class="mastered-term-title">${term}</div>
        <div class="mastered-term-explain">${data.explain}</div>
        <div class="mastered-term-date">æŒæ¡æ—¶é—´: ${new Date().toLocaleDateString('zh-CN')}</div>
      </div>
    `;
    }).filter(Boolean).join('');
    content.innerHTML = termsList;
    console.log('Mastered terms content updated');
}
// â€”â€” é¡µé¢æ–‡æœ¬ä¸è¯†åˆ« â€”â€”
function getPageText() {
    function getTextFromNode(node) {
        if (node.nodeType === Node.TEXT_NODE) {
            return node.textContent || '';
        }
        if (node.nodeType === Node.ELEMENT_NODE &&
            node.tagName !== 'SCRIPT' &&
            node.tagName !== 'STYLE') {
            let text = '';
            node.childNodes.forEach((child) => {
                text += getTextFromNode(child);
            });
            return text;
        }
        return '';
    }
    return getTextFromNode(document.body).replace(/\s+/g, ' ').trim();
}
function detectFinancialTerms(text) {
    const allTerms = getAllTerms();
    return Object.keys(allTerms).filter((term) => text.includes(term));
}
// â€”â€” é«˜äº® â€”â€”
const BLOCKED_TAGS = new Set([
    'SCRIPT',
    'STYLE',
    'NOSCRIPT',
    'TEXTAREA',
    'INPUT',
    'CODE',
    'PRE',
    'SVG',
    'CANVAS',
    'IMG',
    'VIDEO',
    'AUDIO',
]);
function highlightTerms(root, terms) {
    if (terms.length === 0)
        return 0;
    ensureStyles();
    // è¿‡æ»¤æ‰å·²æŒæ¡çš„è¯æ¡
    const termsToHighlight = terms.filter(term => !masteredTerms.has(term));
    if (termsToHighlight.length === 0)
        return 0;
    const pattern = new RegExp('(' + termsToHighlight.map((t) => escapeRegExp(t)).join('|') + ')', 'g');
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
        acceptNode(node) {
            const parent = node.parentElement;
            if (!parent)
                return NodeFilter.FILTER_REJECT;
            if (BLOCKED_TAGS.has(parent.tagName))
                return NodeFilter.FILTER_REJECT;
            if (parent.classList.contains('yiyuan-highlight'))
                return NodeFilter.FILTER_REJECT;
            // å®‰å…¨åœ°æ£€æŸ¥ parent æ˜¯å¦æ”¯æŒ closest æ–¹æ³•
            if (parent && typeof parent.closest === 'function') {
                if (parent.closest('.yiyuan-tooltip,[data-yiyuan-skip="1"]'))
                    return NodeFilter.FILTER_REJECT;
            }
            const txt = node.nodeValue || '';
            return txt.trim() ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
        },
    });
    const textNodes = [];
    let n;
    // eslint-disable-next-line no-cond-assign
    while ((n = walker.nextNode()))
        textNodes.push(n);
    let replaceCount = 0;
    for (const textNode of textNodes) {
        const raw = textNode.nodeValue || '';
        if (!pattern.test(raw))
            continue;
        pattern.lastIndex = 0;
        const frag = document.createDocumentFragment();
        let lastIndex = 0;
        let match;
        // eslint-disable-next-line no-cond-assign
        while ((match = pattern.exec(raw))) {
            const term = match[0];
            if (match.index > lastIndex) {
                frag.appendChild(document.createTextNode(raw.slice(lastIndex, match.index)));
            }
            const span = document.createElement('span');
            span.className = 'yiyuan-highlight';
            span.textContent = term;
            span.setAttribute('data-yiyuan-term', term);
            span.addEventListener('mouseenter', () => {
                const rect = span.getBoundingClientRect();
                showTooltip(term, rect);
            });
            span.addEventListener('mouseleave', () => {
                hideTooltip();
            });
            frag.appendChild(span);
            lastIndex = match.index + term.length;
            replaceCount++;
        }
        if (lastIndex < raw.length) {
            frag.appendChild(document.createTextNode(raw.slice(lastIndex)));
        }
        textNode.parentNode?.replaceChild(frag, textNode);
    }
    return replaceCount;
}
function scanAndHighlight() {
    const text = getPageText();
    const terms = detectFinancialTerms(text).sort((a, b) => b.length - a.length);
    return highlightTerms(document.body, terms);
}
// â€”â€” æ¶ˆæ¯ä¸è‡ªåŠ¨æ‰«æ â€”â€”
chrome.runtime.onMessage.addListener((msg) => {
    if (msg.type === 'PROCESS_PAGE') {
        const count = scanAndHighlight();
        console.info('[FinTerms] manual scan, highlights:', count);
        if (count === 0) {
            alert('æœªæ£€æµ‹åˆ°é‡‘èæœ¯è¯­ã€‚');
        }
    }
    else if (msg.type === 'SHOW_SIDEBAR') {
        showSidebar();
    }
    else if (msg.type === 'EXPLAIN_SELECTION') {
        // æ¥è‡ªæµè§ˆå™¨å³é”®èœå•ï¼ˆselectionï¼‰çš„è§¦å‘
        const text = String(msg.text || '').trim();
        if (!text)
            return;
        // å°è¯•ä»å½“å‰é€‰åŒºè·å–åæ ‡ï¼›è‹¥æ— é€‰åŒºï¼Œåˆ™ä½¿ç”¨è§†å£ä¸­å¿ƒ
        let x = Math.round(window.innerWidth / 2);
        let y = Math.round(window.innerHeight / 2);
        const sel = window.getSelection();
        if (sel && sel.rangeCount > 0) {
            const range = sel.getRangeAt(0);
            const rect = range.getBoundingClientRect();
            if (rect && rect.width + rect.height > 0) {
                x = Math.round(rect.left + Math.min(300, rect.width));
                y = Math.round(rect.top + Math.min(60, rect.height)) + 20;
            }
        }
        if (isValidText(text)) {
            showCustomTermTooltip(text, { x, y });
        }
        else {
            showErrorMessage('æ‰€é€‰æ–‡æœ¬ä¸ç¬¦åˆè§£è¯»æ¡ä»¶ï¼ˆéœ€ä¸»è¦ä¸ºä¸­æ–‡æˆ–è‹±æ–‡ï¼Œâ‰¤15å­—ç¬¦ï¼‰');
        }
    }
});
let featureEnabled = true;
let scanDebounceId = null;
function triggerScanDebounced(delayMs = 400) {
    if (!featureEnabled)
        return;
    if (scanDebounceId !== null)
        window.clearTimeout(scanDebounceId);
    scanDebounceId = window.setTimeout(() => {
        const count = scanAndHighlight();
        console.info('[FinTerms] auto scan, highlights:', count);
    }, delayMs);
}
async function initAutoScan() {
    try {
        const { enabled } = await chrome.storage.sync.get(['enabled']);
        featureEnabled = enabled !== false; // é»˜è®¤å¼€å¯
    }
    catch {
        featureEnabled = true;
    }
    // åŠ è½½è¯æ¡æ•°æ®
    await loadTermsData();
    const runInitial = () => triggerScanDebounced(0);
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', runInitial, { once: true });
    }
    else {
        runInitial();
    }
    const mo = new MutationObserver((mutations) => {
        for (const m of mutations) {
            if (m.addedNodes && m.addedNodes.length > 0) {
                let shouldScan = false;
                for (const nd of Array.from(m.addedNodes)) {
                    if (nd.nodeType === Node.ELEMENT_NODE) {
                        const el = nd;
                        // å¦‚æœå˜æ›´ä»…å‘ç”Ÿåœ¨ tooltip å†…éƒ¨ï¼Œåˆ™è·³è¿‡
                        if (el && typeof el.closest === 'function' && (el.closest('.yiyuan-tooltip') || el.closest('[data-yiyuan-skip="1"]'))) {
                            continue;
                        }
                    }
                    shouldScan = true;
                }
                if (shouldScan) {
                    triggerScanDebounced();
                    break;
                }
            }
        }
    });
    mo.observe(document.documentElement, { childList: true, subtree: true });
    window.addEventListener('resize', () => hideTooltip());
    window.addEventListener('scroll', () => hideTooltip(), { capture: true, passive: true });
    // ç›‘å¬å¼¹çª—çš„é¼ æ ‡äº‹ä»¶ï¼Œé˜²æ­¢hoveræ—¶æ¶ˆå¤±
    document.addEventListener('mouseover', (e) => {
        const el = getEventElement(e);
        if (el && typeof el.closest === 'function' && el.closest('[data-yiyuan-skip="1"]')) {
            cancelHideTooltip(); // é¼ æ ‡è¿›å…¥å¼¹çª—æ—¶å–æ¶ˆéšè—
        }
    }, { capture: true });
    document.addEventListener('mouseleave', (e) => {
        const el = getEventElement(e);
        if (el && typeof el.closest === 'function' && el.closest('[data-yiyuan-skip="1"]')) {
            hideTooltip(); // é¼ æ ‡ç¦»å¼€å¼¹çª—æ—¶å¯åŠ¨éšè—å®šæ—¶å™¨
        }
    }, { capture: true });
    // ç›‘å¬å³é”®èœå•äº‹ä»¶ï¼ˆæ•è·é˜¶æ®µï¼‰ï¼Œæå‡è¢«ç«™ç‚¹å¼¹çª—/é®ç½©æ‹¦æˆªæ—¶çš„å…¼å®¹æ€§
    document.addEventListener('contextmenu', (e) => {
        const selection = window.getSelection();
        if (selection && selection.toString().trim()) {
            const selectedText = selection.toString().trim();
            // æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆçš„ä¸­æ–‡æ–‡æœ¬ä¸”ä¸è¶…è¿‡15ä¸ªå­—ç¬¦
            if (isValidText(selectedText)) {
                // é¿å…ä¸ç«™ç‚¹çš„å³é”®èœå•å†²çªï¼Œä½†ä¸å¼ºåˆ¶é˜»æ­¢é»˜è®¤ï¼Œä¿æŒå¯å›é€€åˆ°æµè§ˆå™¨å³é”®èœå•
                try {
                    e.preventDefault();
                }
                catch { }
                showContextMenu(e.clientX, e.clientY, selectedText);
            }
        }
    }, { capture: true });
    // ç‚¹å‡»å…¶ä»–åœ°æ–¹éšè—å³é”®èœå•
    document.addEventListener('click', () => {
        hideContextMenu();
    }, { capture: true });
    // æŒ‰ESCé”®éšè—å³é”®èœå•
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            hideContextMenu();
            hideTooltip();
        }
    }, { capture: true });
}
initAutoScan();
// æ–‡ä»¶ç»“æŸ
